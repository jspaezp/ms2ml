{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ms2ml Documentation site: https://jspaezp.github.io/ms2ml/encoding_options/ GitHub: https://github.com/jspaezp/ms2ml This package is in early development, I am actively taking ideas and requests The idea of this package is to have an intermeiate layer between the pyteomics package and ML applications. Since ML applications do not take MS data as input directly, it is necessary to convert/encode it. This package is meant to handle that aspect. This project is meant to be opinionated but not arbitrary. By that I mean that it should attempt to enforce the \"better way\" of doing things (not give flexibility to do everything every way) but all design decisions are open to discussion (ideally though github). Installation pip install ms2ml Usage from ms2ml.config import Config from ms2ml.data.adapters import MSPAdapter # From proteometools my_file = \"FTMS_HCD_20_annotated_2019-11-12.msp\" def post_hook ( spec ): return { \"aa\" : spec . precursor_peptide . aa_to_onehot (), \"mods\" : spec . precursor_peptide . mod_to_vector (), } my_adapter = MSPAdapter ( file = my_file , config = Config (), out_hook = post_hook ) bundled = my_adapter . bundle ( my_adapter . parse ()) print ({ k : f \" { type ( v ) : of shape: { v . shape }} \" for k , v in bundled . items ()}) # {'aa': \"<class 'numpy.ndarray'>: of shape: (N, 42, 29)\", # 'mods': \"<class 'numpy.ndarray'>: of shape: (N, 42)\"} Core parts (subject to change...) Parsers for external data are in ./ms2ml/data/parsing Parsers should only be able to read data and return a base python representation, dict/list etc. Adapters are located in ./ms2ml/adapters, they should build on parsers (usually) but yield ms2ml representation objects (Spectrum, Peptide, AnnotatedSpectrum, LCMSSpectrum). Behavior can be modified/extended using hooks. ms2ml representation objects have methods that converts them into tensor representations (Peptide.aa_to_onehot for instance) As much configuration as possible should be stored in the config.Config class. It should contain information on the project and the way everything is getting encoded, so hypothetically one could just pass a config to a different data source adapter and get compatible results. What position of the onehot is alanine? look at the config WHat order are our ions encoded in? Look at the config. Core design Unified configuration All configuration should be explicit or immediately visible upon request Consistent API It should feel similar to process the data inernally regardless of the input. Flexible output Every research need is different, therefore requesting different data from the API should be straightforward. Extensibility. It should be easy to adapt workflows to new and unexpected input data types. This is achieved with the addition of hooks that allow an additional slim layer of compatibility Abstract the loops away I do not like writting boilerplate code, neither should you. Ideally you will not need to write loops when using the user-facing API Therefore I try my best to abstract all the [f(spec) for spec in file] within reason. Fail loudly It is already hard to debug ML models, lets make it easier by having sensical error messages and checks. They should also contain suggestions to fix the bug. Explicit is better than implicit. Errors are better than bugs. Api documentation. Documentation is critical, if it is not documented, It will be deleted (because nobody will use it ...) Within reason, all external api should be documented, typed, in-code commented, have a docstring, check that it renders well using mkdocs and an example. All classes should have a static _sample static method that gives a sample of that object, and its docstring shoudl include an example on how to generate it. Target audience People who want to train ML models from peptide/proteomics data instead of figuring out ways to encode their tensors and write parsers. %%{init: {'theme': 'base', 'themeVariables': { 'primaryBorderColor': '#666666', 'primaryColor': '#ffffff', 'edgeLabelBackground':'#ffffff', 'tertiaryColor': '#666666'}}}%% flowchart TB raw[\"Raw Data: .raw\"] mzml[\"Converted Data: .mzML\"] pepxml[\"Searched Data: .pep.xml\"] pout[\"FDR controlled Data: .pep.xml .pout\"] speclib[\"Spectral library: .ms2 .blib .sptxt .msp\"] tensor[\"Encoded Spectra: np.array torch.tensor\"] tensorcache[\"Tensor Cache: .hdf5 .csv .feather\"] mlmodel[\"ML model: torch.nn.Module tf.keras.nn\"] randomscript[\"Self-implemented script .py .R\"] msconvert[MSConvert] searchengine[Search Engine: comet,msfragger...] fdrvalidator[FDR validator: peptideprophet, Percolator, Mokapot] speclibbuilder[Spectral Library Builder] ms2ml[MS2ML] raw --> msconvert msconvert --> mzml raw --> searchengine searchengine --> pepxml mzml --> searchengine pepxml --> fdrvalidator fdrvalidator --> pout pout --> speclibbuilder speclibbuilder --> speclib pout --> randomscript randomscript --> tensor speclib --> randomscript tensor --> mlmodel tensor --> tensorcache tensorcache --> mlmodel tensorcache --> randomscript randomscript --> mlmodel speclib --> ms2ml ms2ml --> mlmodel linkStyle 10,11,12,13,14,15,16 stroke:#db7093,stroke-width:5px; linkStyle 17,18 stroke:#008000,stroke-width:5px; style msconvert stroke:#00ffff,stroke-width:4px style searchengine stroke:#00ffff,stroke-width:4px style fdrvalidator stroke:#00ffff,stroke-width:4px style speclibbuilder stroke:#00ffff,stroke-width:4px style raw fill:#cccccc,stroke-width:2px style mzml fill:#cccccc,stroke-width:2px style pepxml fill:#cccccc,stroke-width:2px style pout fill:#cccccc,stroke-width:2px style speclib fill:#cccccc,stroke-width:2px style ms2ml fill:#ee82ee,stroke:#b882ee,stroke-width:4px Peptide sequence notation When possible I will attempt to allow 'Proforma' based sequence annotations. Check: https://pyteomics.readthedocs.io/en/latest/api/proforma.html http://psidev.info/sites/default/files/2020-12/ProForma_v2_draft12_0.pdf https://www.psidev.info/proforma TODO [ ] Config [ ] Handle variable modifications [ ] Documentation, Documentation, Documentation [ ] Helper Annotation classes Similar projects: https://matchms.readthedocs.io/en/latest/: Matchms is an open-access Python package to import, process, clean, and compare mass spectrometry data (MS/MS). It allows to implement and run an easy-to-follow, easy-to-reproduce workflow from raw mass spectra to pre- and post-processed spectral data. Tailored for small molecule data https://gitlab.com/roettgerlab/ms2ai: MS2AI from Tobias Rehfeldt (who is also part of the ProteomicsML project) Uses maxquant to for a full PRIDE to ml workflow. https://github.com/wilhelm-lab/dlomix DLOmix from Mathias Wilhelm\u2019s group Tensorflow centric implementatino of ml models for proteomcs https://github.com/wfondrie/depthcharge Depthcharge is a deep learning toolkit for building state-of-the-art models to analyze mass spectra generated from peptides other and molecules. It seems to focus on the model generation, rather than proving flexibility in encoding. https://github.com/bittremieux/spectrum_utils spectrum_utils is a Python package for efficient mass spectrometry data processing and visualization. Many of the spectrum processing aspects are similar but there is no focus in parsing or exporting encoding. Contribution Right not this is a proof of concept package, I would be happy to make it something more stable if there is interest. Feel free to open an issue and we can discuss what you need out of it!! (and decide who can implement it)","title":"Home"},{"location":"#ms2ml","text":"Documentation site: https://jspaezp.github.io/ms2ml/encoding_options/ GitHub: https://github.com/jspaezp/ms2ml This package is in early development, I am actively taking ideas and requests The idea of this package is to have an intermeiate layer between the pyteomics package and ML applications. Since ML applications do not take MS data as input directly, it is necessary to convert/encode it. This package is meant to handle that aspect. This project is meant to be opinionated but not arbitrary. By that I mean that it should attempt to enforce the \"better way\" of doing things (not give flexibility to do everything every way) but all design decisions are open to discussion (ideally though github).","title":"ms2ml"},{"location":"#installation","text":"pip install ms2ml","title":"Installation"},{"location":"#usage","text":"from ms2ml.config import Config from ms2ml.data.adapters import MSPAdapter # From proteometools my_file = \"FTMS_HCD_20_annotated_2019-11-12.msp\" def post_hook ( spec ): return { \"aa\" : spec . precursor_peptide . aa_to_onehot (), \"mods\" : spec . precursor_peptide . mod_to_vector (), } my_adapter = MSPAdapter ( file = my_file , config = Config (), out_hook = post_hook ) bundled = my_adapter . bundle ( my_adapter . parse ()) print ({ k : f \" { type ( v ) : of shape: { v . shape }} \" for k , v in bundled . items ()}) # {'aa': \"<class 'numpy.ndarray'>: of shape: (N, 42, 29)\", # 'mods': \"<class 'numpy.ndarray'>: of shape: (N, 42)\"}","title":"Usage"},{"location":"#core-parts","text":"(subject to change...) Parsers for external data are in ./ms2ml/data/parsing Parsers should only be able to read data and return a base python representation, dict/list etc. Adapters are located in ./ms2ml/adapters, they should build on parsers (usually) but yield ms2ml representation objects (Spectrum, Peptide, AnnotatedSpectrum, LCMSSpectrum). Behavior can be modified/extended using hooks. ms2ml representation objects have methods that converts them into tensor representations (Peptide.aa_to_onehot for instance) As much configuration as possible should be stored in the config.Config class. It should contain information on the project and the way everything is getting encoded, so hypothetically one could just pass a config to a different data source adapter and get compatible results. What position of the onehot is alanine? look at the config WHat order are our ions encoded in? Look at the config.","title":"Core parts"},{"location":"#core-design","text":"Unified configuration All configuration should be explicit or immediately visible upon request Consistent API It should feel similar to process the data inernally regardless of the input. Flexible output Every research need is different, therefore requesting different data from the API should be straightforward. Extensibility. It should be easy to adapt workflows to new and unexpected input data types. This is achieved with the addition of hooks that allow an additional slim layer of compatibility Abstract the loops away I do not like writting boilerplate code, neither should you. Ideally you will not need to write loops when using the user-facing API Therefore I try my best to abstract all the [f(spec) for spec in file] within reason. Fail loudly It is already hard to debug ML models, lets make it easier by having sensical error messages and checks. They should also contain suggestions to fix the bug. Explicit is better than implicit. Errors are better than bugs. Api documentation. Documentation is critical, if it is not documented, It will be deleted (because nobody will use it ...) Within reason, all external api should be documented, typed, in-code commented, have a docstring, check that it renders well using mkdocs and an example. All classes should have a static _sample static method that gives a sample of that object, and its docstring shoudl include an example on how to generate it.","title":"Core design"},{"location":"#target-audience","text":"People who want to train ML models from peptide/proteomics data instead of figuring out ways to encode their tensors and write parsers. %%{init: {'theme': 'base', 'themeVariables': { 'primaryBorderColor': '#666666', 'primaryColor': '#ffffff', 'edgeLabelBackground':'#ffffff', 'tertiaryColor': '#666666'}}}%% flowchart TB raw[\"Raw Data: .raw\"] mzml[\"Converted Data: .mzML\"] pepxml[\"Searched Data: .pep.xml\"] pout[\"FDR controlled Data: .pep.xml .pout\"] speclib[\"Spectral library: .ms2 .blib .sptxt .msp\"] tensor[\"Encoded Spectra: np.array torch.tensor\"] tensorcache[\"Tensor Cache: .hdf5 .csv .feather\"] mlmodel[\"ML model: torch.nn.Module tf.keras.nn\"] randomscript[\"Self-implemented script .py .R\"] msconvert[MSConvert] searchengine[Search Engine: comet,msfragger...] fdrvalidator[FDR validator: peptideprophet, Percolator, Mokapot] speclibbuilder[Spectral Library Builder] ms2ml[MS2ML] raw --> msconvert msconvert --> mzml raw --> searchengine searchengine --> pepxml mzml --> searchengine pepxml --> fdrvalidator fdrvalidator --> pout pout --> speclibbuilder speclibbuilder --> speclib pout --> randomscript randomscript --> tensor speclib --> randomscript tensor --> mlmodel tensor --> tensorcache tensorcache --> mlmodel tensorcache --> randomscript randomscript --> mlmodel speclib --> ms2ml ms2ml --> mlmodel linkStyle 10,11,12,13,14,15,16 stroke:#db7093,stroke-width:5px; linkStyle 17,18 stroke:#008000,stroke-width:5px; style msconvert stroke:#00ffff,stroke-width:4px style searchengine stroke:#00ffff,stroke-width:4px style fdrvalidator stroke:#00ffff,stroke-width:4px style speclibbuilder stroke:#00ffff,stroke-width:4px style raw fill:#cccccc,stroke-width:2px style mzml fill:#cccccc,stroke-width:2px style pepxml fill:#cccccc,stroke-width:2px style pout fill:#cccccc,stroke-width:2px style speclib fill:#cccccc,stroke-width:2px style ms2ml fill:#ee82ee,stroke:#b882ee,stroke-width:4px","title":"Target audience"},{"location":"#peptide-sequence-notation","text":"When possible I will attempt to allow 'Proforma' based sequence annotations. Check: https://pyteomics.readthedocs.io/en/latest/api/proforma.html http://psidev.info/sites/default/files/2020-12/ProForma_v2_draft12_0.pdf https://www.psidev.info/proforma","title":"Peptide sequence notation"},{"location":"#todo","text":"[ ] Config [ ] Handle variable modifications [ ] Documentation, Documentation, Documentation [ ] Helper Annotation classes","title":"TODO"},{"location":"#similar-projects","text":"https://matchms.readthedocs.io/en/latest/: Matchms is an open-access Python package to import, process, clean, and compare mass spectrometry data (MS/MS). It allows to implement and run an easy-to-follow, easy-to-reproduce workflow from raw mass spectra to pre- and post-processed spectral data. Tailored for small molecule data https://gitlab.com/roettgerlab/ms2ai: MS2AI from Tobias Rehfeldt (who is also part of the ProteomicsML project) Uses maxquant to for a full PRIDE to ml workflow. https://github.com/wilhelm-lab/dlomix DLOmix from Mathias Wilhelm\u2019s group Tensorflow centric implementatino of ml models for proteomcs https://github.com/wfondrie/depthcharge Depthcharge is a deep learning toolkit for building state-of-the-art models to analyze mass spectra generated from peptides other and molecules. It seems to focus on the model generation, rather than proving flexibility in encoding. https://github.com/bittremieux/spectrum_utils spectrum_utils is a Python package for efficient mass spectrometry data processing and visualization. Many of the spectrum processing aspects are similar but there is no focus in parsing or exporting encoding.","title":"Similar projects:"},{"location":"#contribution","text":"Right not this is a proof of concept package, I would be happy to make it something more stable if there is interest. Feel free to open an issue and we can discuss what you need out of it!! (and decide who can implement it)","title":"Contribution"},{"location":"adapters/","text":"Adapters Adapters are objects that implement interfaces between raw data, usally stored externally, to the internal representation objects. Just as a reminder, these objects are the Peptide , the Spectrum and the AnnotatedPeptideSpectrum . For details on the available adapters, take a look at the adapter section inside the ms2ml API documents. Basic Usage from tempfile import NamedTemporaryFile from ms2ml.data.adapters import MSPAdapter from ms2ml.config import Config from pprint import pprint # A very boring msp with 2 spectra text = ( \"Name: ASDASD/2 \\n \" \"MW: 1234 \\n \" '123 123 \"asd\" \\n ' \" \\n \" \"Name: ASDASDAAS/1 \\n \" \"MW: 12343 \\n \" '123 123 \"as5d\" \\n ' '123 123 \"asd\" \\n ' \" \\n \" ) f = NamedTemporaryFile ( delete = False ) with open ( f . name , \"w\" ) as f : f . write ( text ) my_file = f . name my_adapter = MSPAdapter ( config = Config (), file = my_file ) pprint ( list ( my_adapter . parse ())) output [AnnotatedPeptideSpectrum(mz=array([123.]), intensity=array([123.]), ms_level=2, precursor_mz=0, precursor_charge=2, instrument=None, analyzer=None, collision_energy=nan, activation=None, extras=None, retention_time=RetentionTime(rt=nan, units='seconds', run=None), precursor_peptide=Peptide([('A', None), ('S', None), ('D', None), ('A', None), ('S', None), ('D', None)], {'n_term': None, 'c_term': None, 'unlocalized_modifications': [], 'labile_modifications': [], 'fixed_modifications': [], 'intervals': [], 'isotopes': [], 'group_ids': [], 'charge_state': ChargeState(2, [])}), precursor_isotope=0), AnnotatedPeptideSpectrum(mz=array([123., 123.]), intensity=array([123., 123.]), ms_level=2, precursor_mz=0, precursor_charge=1, instrument=None, analyzer=None, collision_energy=nan, activation=None, extras=None, retention_time=RetentionTime(rt=nan, units='seconds', run=None), precursor_peptide=Peptide([('A', None), ('S', None), ('D', None), ('A', None), ('S', None), ('D', None), ('A', None), ('A', None), ('S', None)], {'n_term': None, 'c_term': None, 'unlocalized_modifications': [], 'labile_modifications': [], 'fixed_modifications': [], 'intervals': [], 'isotopes': [], 'group_ids': [], 'charge_state': ChargeState(1, [])}), precursor_isotope=0)] Hook usage to modify the output We will keep using the same file as before, but we will add a hook to modify the output. Since every intermediate entry is an annotated Spectrum object, we can get the corresponding peptide from spec.precurse_peptide and encode it on the fly and return an dictionary of tensors! We could in theory do this in a loop .... something like this ... my_adapter = MSPAdapter(config=Config(), file = my_file) out1 = [] out2 = [] for i, x in enumerate(my_adapter.parse()): out1.append(x.precurse_peptide.aa_to_count()) out2.append(x.precurse_peptide.mod_to_vector()) out1 = np.array(out1) out2 = np.array(out2) print(out1.shape) print(out2.shape) Or we can use the hook system to do it for us! def post_hook ( spec ): return { \"aa\" : spec . precursor_peptide . aa_to_count (), \"mods\" : spec . precursor_peptide . mod_to_vector (), } my_adapter . out_hook = post_hook # We can also add the hook when deifing the adapter # my_adapter = MSPAdapter( # file=my_file, config=Config(), out_hook=post_hook # ) for i , x in enumerate ( my_adapter . parse ()): print ( i ) pprint ( x ) output 0 {'aa': array([1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0]), 'mods': array([0, 0, 0, 0, 0, 0, 0, 0])} 1 {'aa': array([1, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0]), 'mods': array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])} We can even combine those outputs into batches using the bundle method. bundled = my_adapter . bundle ( my_adapter . parse ()) pprint ({ k : v . shape for k , v in bundled . items ()}) output {'aa': (2, 29), 'mods': (2, 11)} stderr /home/runner/work/ms2ml/ms2ml/ms2ml/utils/tensor_utils.py:110: UserWarning: Padding to shape (11,) because the shapes are not the same warnings.warn( pprint ( bundled ) output {'aa': array([[1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0]]), 'mods': array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])} Changing the configuration We can also change the configuration of the adapter to change the output. This makes sense if the way your model is trained requires a different variation of the encoding. my_conf = Config ( encoding_aa_order = ( 'A' , 'S' , 'D' )) my_adapter = MSPAdapter ( file = my_file , config = Config (), out_hook = post_hook ) bundled = my_adapter . bundle ( my_adapter . parse ()) print ( \"Default Shapes:\" ) pprint ({ k : v . shape for k , v in bundled . items ()}) my_adapter . config = my_conf bundled = my_adapter . bundle ( my_adapter . parse ()) print ( \"Configured Shapes:\" ) pprint ({ k : v . shape for k , v in bundled . items ()}) output Default Shapes: {'aa': (2, 29), 'mods': (2, 11)} Configured Shapes: {'aa': (2, 3), 'mods': (2, 11)} Note that the 'aa' element only has 3 dimensions, since we only have 3 defined aminoacids in the configuration!! # We close the connection to the dummy file because we are good # programmers f . close () Batching Sometimes we dont want either 1 element at a time or all of them at a time. For those cases, we batch. In this case we can get form a file of 1000 spectra, 10 at a time. # Same setup as before but for a much larger file (1000 spectra) f = NamedTemporaryFile ( delete = False ) with open ( f . name , \"w\" ) as f : # We make a file with 1000 spectra f . write ( text * 500 ) my_file = f . name def post_hook ( spec ): return { \"aa\" : spec . precursor_peptide . aa_to_count (), \"mods\" : spec . precursor_peptide . mod_to_vector (), } When defining the adapter, we can specify the collate_fn. This function is called to combine all the elements in a batch. it can be something as simple as as 'list' or something as complicated as you want to make it. (np.stack, torch.stack, torch.cat, combinations of the former ... the sky is the limit) my_adapter = MSPAdapter ( config = Config (), file = my_file , out_hook = post_hook , collate_fn = lambda x : x ) Here we define the batch_size to be 10. for i , x in enumerate ( my_adapter . batch ( batch_size = 10 )): print ( i ) break print ( x [ 1 ]) print ( len ( x )) print ( type ( x )) # The shapes of every element in the batch output 0 {'aa': array([1, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0]), 'mods': array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])} 10 And every iteration, x is a new group of 10 peptides, encoded the way we specified before. my_adapter = MSPAdapter ( config = Config (), file = my_file , out_hook = post_hook ) for i , x in enumerate ( my_adapter . batch ( batch_size = 4 )): print ( i ) break pprint ( x ) print ( len ( x )) print ( type ( x )) f . close () output 0 {'aa': array([[1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0]]), 'mods': array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])} 2","title":"Adapters"},{"location":"adapters/#adapters","text":"Adapters are objects that implement interfaces between raw data, usally stored externally, to the internal representation objects. Just as a reminder, these objects are the Peptide , the Spectrum and the AnnotatedPeptideSpectrum . For details on the available adapters, take a look at the adapter section inside the ms2ml API documents.","title":"Adapters"},{"location":"adapters/#basic-usage","text":"from tempfile import NamedTemporaryFile from ms2ml.data.adapters import MSPAdapter from ms2ml.config import Config from pprint import pprint # A very boring msp with 2 spectra text = ( \"Name: ASDASD/2 \\n \" \"MW: 1234 \\n \" '123 123 \"asd\" \\n ' \" \\n \" \"Name: ASDASDAAS/1 \\n \" \"MW: 12343 \\n \" '123 123 \"as5d\" \\n ' '123 123 \"asd\" \\n ' \" \\n \" ) f = NamedTemporaryFile ( delete = False ) with open ( f . name , \"w\" ) as f : f . write ( text ) my_file = f . name my_adapter = MSPAdapter ( config = Config (), file = my_file ) pprint ( list ( my_adapter . parse ())) output [AnnotatedPeptideSpectrum(mz=array([123.]), intensity=array([123.]), ms_level=2, precursor_mz=0, precursor_charge=2, instrument=None, analyzer=None, collision_energy=nan, activation=None, extras=None, retention_time=RetentionTime(rt=nan, units='seconds', run=None), precursor_peptide=Peptide([('A', None), ('S', None), ('D', None), ('A', None), ('S', None), ('D', None)], {'n_term': None, 'c_term': None, 'unlocalized_modifications': [], 'labile_modifications': [], 'fixed_modifications': [], 'intervals': [], 'isotopes': [], 'group_ids': [], 'charge_state': ChargeState(2, [])}), precursor_isotope=0), AnnotatedPeptideSpectrum(mz=array([123., 123.]), intensity=array([123., 123.]), ms_level=2, precursor_mz=0, precursor_charge=1, instrument=None, analyzer=None, collision_energy=nan, activation=None, extras=None, retention_time=RetentionTime(rt=nan, units='seconds', run=None), precursor_peptide=Peptide([('A', None), ('S', None), ('D', None), ('A', None), ('S', None), ('D', None), ('A', None), ('A', None), ('S', None)], {'n_term': None, 'c_term': None, 'unlocalized_modifications': [], 'labile_modifications': [], 'fixed_modifications': [], 'intervals': [], 'isotopes': [], 'group_ids': [], 'charge_state': ChargeState(1, [])}), precursor_isotope=0)]","title":"Basic Usage"},{"location":"adapters/#hook-usage-to-modify-the-output","text":"We will keep using the same file as before, but we will add a hook to modify the output. Since every intermediate entry is an annotated Spectrum object, we can get the corresponding peptide from spec.precurse_peptide and encode it on the fly and return an dictionary of tensors! We could in theory do this in a loop .... something like this ... my_adapter = MSPAdapter(config=Config(), file = my_file) out1 = [] out2 = [] for i, x in enumerate(my_adapter.parse()): out1.append(x.precurse_peptide.aa_to_count()) out2.append(x.precurse_peptide.mod_to_vector()) out1 = np.array(out1) out2 = np.array(out2) print(out1.shape) print(out2.shape) Or we can use the hook system to do it for us! def post_hook ( spec ): return { \"aa\" : spec . precursor_peptide . aa_to_count (), \"mods\" : spec . precursor_peptide . mod_to_vector (), } my_adapter . out_hook = post_hook # We can also add the hook when deifing the adapter # my_adapter = MSPAdapter( # file=my_file, config=Config(), out_hook=post_hook # ) for i , x in enumerate ( my_adapter . parse ()): print ( i ) pprint ( x ) output 0 {'aa': array([1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0]), 'mods': array([0, 0, 0, 0, 0, 0, 0, 0])} 1 {'aa': array([1, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0]), 'mods': array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])} We can even combine those outputs into batches using the bundle method. bundled = my_adapter . bundle ( my_adapter . parse ()) pprint ({ k : v . shape for k , v in bundled . items ()}) output {'aa': (2, 29), 'mods': (2, 11)} stderr /home/runner/work/ms2ml/ms2ml/ms2ml/utils/tensor_utils.py:110: UserWarning: Padding to shape (11,) because the shapes are not the same warnings.warn( pprint ( bundled ) output {'aa': array([[1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0]]), 'mods': array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])}","title":"Hook usage to modify the output"},{"location":"adapters/#changing-the-configuration","text":"We can also change the configuration of the adapter to change the output. This makes sense if the way your model is trained requires a different variation of the encoding. my_conf = Config ( encoding_aa_order = ( 'A' , 'S' , 'D' )) my_adapter = MSPAdapter ( file = my_file , config = Config (), out_hook = post_hook ) bundled = my_adapter . bundle ( my_adapter . parse ()) print ( \"Default Shapes:\" ) pprint ({ k : v . shape for k , v in bundled . items ()}) my_adapter . config = my_conf bundled = my_adapter . bundle ( my_adapter . parse ()) print ( \"Configured Shapes:\" ) pprint ({ k : v . shape for k , v in bundled . items ()}) output Default Shapes: {'aa': (2, 29), 'mods': (2, 11)} Configured Shapes: {'aa': (2, 3), 'mods': (2, 11)} Note that the 'aa' element only has 3 dimensions, since we only have 3 defined aminoacids in the configuration!! # We close the connection to the dummy file because we are good # programmers f . close ()","title":"Changing the configuration"},{"location":"adapters/#batching","text":"Sometimes we dont want either 1 element at a time or all of them at a time. For those cases, we batch. In this case we can get form a file of 1000 spectra, 10 at a time. # Same setup as before but for a much larger file (1000 spectra) f = NamedTemporaryFile ( delete = False ) with open ( f . name , \"w\" ) as f : # We make a file with 1000 spectra f . write ( text * 500 ) my_file = f . name def post_hook ( spec ): return { \"aa\" : spec . precursor_peptide . aa_to_count (), \"mods\" : spec . precursor_peptide . mod_to_vector (), } When defining the adapter, we can specify the collate_fn. This function is called to combine all the elements in a batch. it can be something as simple as as 'list' or something as complicated as you want to make it. (np.stack, torch.stack, torch.cat, combinations of the former ... the sky is the limit) my_adapter = MSPAdapter ( config = Config (), file = my_file , out_hook = post_hook , collate_fn = lambda x : x ) Here we define the batch_size to be 10. for i , x in enumerate ( my_adapter . batch ( batch_size = 10 )): print ( i ) break print ( x [ 1 ]) print ( len ( x )) print ( type ( x )) # The shapes of every element in the batch output 0 {'aa': array([1, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0]), 'mods': array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])} 10 And every iteration, x is a new group of 10 peptides, encoded the way we specified before. my_adapter = MSPAdapter ( config = Config (), file = my_file , out_hook = post_hook ) for i , x in enumerate ( my_adapter . batch ( batch_size = 4 )): print ( i ) break pprint ( x ) print ( len ( x )) print ( type ( x )) f . close () output 0 {'aa': array([[1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0]]), 'mods': array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])} 2","title":"Batching"},{"location":"encoding_options/","text":"Encodings to tensors When getting the data into your model, you usually will have to process it to some form of structured numeric input. There is a plethora fo ways to encode information. And I will show a couple (and how to get them using ms2ml) Encoding Peptides import numpy as np from ms2ml.peptide import Peptide p = Peptide . from_sequence ( \"MYPEPTIDE\" ) print ( p ) output Peptide.from_sequence('MYPEPTIDE') stderr /home/runner/work/ms2ml/ms2ml/ms2ml/config.py:392: UserWarning: Using default config. Consider creating your own. warnings.warn(\"Using default config. Consider creating your own.\", UserWarning) Counting count = p . aa_to_count () print ( count ) output [1 0 0 0 1 2 0 0 0 1 0 0 0 1 0 0 2 0 0 0 1 0 0 0 0 1 0 1 0] One-hot encoding oh = p . aa_to_onehot () # Note that there is an equivalent method for the modifications # p.mod_to_onehot() print ( oh ) output [[1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0]] Vectorizing vec = p . aa_to_vector () print ( vec ) output [ 0 13 25 16 5 16 20 9 4 5 27] Encoding Spectra from ms2ml.spectrum import Spectrum from ms2ml.config import Config spectrum = Spectrum ( mz = np . array ([ 1000.0 , 1500.0 , 2000.0 ]), intensity = np . array ([ 1.0 , 2.0 , 3.0 ]), ms_level = 2 , precursor_mz = 1000.0 , ) print ( spectrum ) output Spectrum(mz=array([1000., 1500., 2000.]), intensity=array([1., 2., 3.]), ms_level=2, precursor_mz=1000.0, precursor_charge=None, instrument=None, analyzer=None, collision_energy=nan, activation=None, extras={}, retention_time=RetentionTime(rt=nan, units='seconds', run=None)) Binning binned = spectrum . bin_spectrum ( start = 500.0 , end = 1500.0 , binsize = 100.0 , # For the real world this would be 1 or 0.02 ... ) # or .... binned = spectrum . bin_spectrum ( start = 500.0 , end = 1500.0 , n_bins = 10 , ) print ( binned ) output [0. 0. 0. 0. 1. 0. 0. 0. 2.] # or .... binned = spectrum . bin_spectrum ( start = - 500.0 , end = + 500.0 , binsize = 100.0 , relative = True , # Will make all bins relative to the precursor mz ) # or .... binned = spectrum . bin_spectrum ( start = - 500.0 , end = + 500.0 , binsize = 100.0 , relative = 600 , # Will make all bins relative to 600! get_breaks = True ) binned_spectrum , bin_breaks = binned print ( binned_spectrum ) print ( bin_breaks ) output [0. 0. 1. 0. 0. 0. 0. 2. 0.] [ 100. 211.11111111 322.22222222 433.33333333 544.44444444 655.55555556 766.66666667 877.77777778 988.88888889 1100. ] Encoding annotated spectra from ms2ml.spectrum import AnnotatedPeptideSpectrum config = Config () peptide = Peptide . from_sequence ( \"PEPPINK/2\" , config ) spectrum = AnnotatedPeptideSpectrum ( mz = np . array ([ 50.0 , 147.11333 , 1000.0 , 1500.0 , 2000.0 ]), intensity = np . array ([ 50.0 , 200.0 , 1.0 , 2.0 , 3.0 ]), ms_level = 2 , precursor_peptide = peptide , precursor_mz = 147.11333 , ) spectrum print ( spectrum ) output AnnotatedPeptideSpectrum(mz=array([ 50. , 147.11333, 1000. , 1500. , 2000. ]), intensity=array([ 50., 200., 1., 2., 3.]), ms_level=2, precursor_mz=147.11333, precursor_charge=2, instrument=None, analyzer=None, collision_energy=nan, activation=None, extras={}, retention_time=RetentionTime(rt=nan, units='seconds', run=None), precursor_peptide=Peptide([('P', None), ('E', None), ('P', None), ('P', None), ('I', None), ('N', None), ('K', None)], {'n_term': None, 'c_term': None, 'unlocalized_modifications': [], 'labile_modifications': [], 'fixed_modifications': [], 'intervals': [], 'isotopes': [], 'group_ids': [], 'charge_state': ChargeState(2, [])}), precursor_isotope=0) spectrum . encode_fragments () stderr 2023-01-10 19:52:55.189 | DEBUG | ms2ml.proforma_utils:mod_id_mass:117 - Resolving mod_id: 21 stderr 2023-01-10 19:52:55.190 | DEBUG | ms2ml.proforma_utils:solver:84 - Initializing UnimodResolver stderr 2023-01-10 19:52:55.642 | DEBUG | ms2ml.proforma_utils:mod_id_mass:119 - Resolved to {'date_time_modified': datetime.datetime(2018, 8, 13, 13, 42, 59), 'date_time_posted': datetime.datetime(2002, 8, 19, 19, 17, 11), 'avge_mass': 79.9799, 'mono_mass': 79.966331, 'composition': Composition({'H': 1, 'O': 3, 'P': 1}), 'record_id': 21, 'approved': True, 'title': 'Phospho', 'full_name': 'Phosphorylation', 'username_of_poster': 'unimod', 'group_of_poster': 'admin', 'specificity': [{'hidden': True, 'spec_group': 8, 'site': 'E', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': True, 'spec_group': 6, 'site': 'R', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': True, 'spec_group': 7, 'site': 'K', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': True, 'spec_group': 4, 'site': 'H', 'position': 'Anywhere', 'classification': 'Post-translational', 'note': 'Rare'}, {'hidden': True, 'spec_group': 5, 'site': 'C', 'position': 'Anywhere', 'classification': 'Post-translational', 'note': 'Rare'}, {'hidden': True, 'spec_group': 3, 'site': 'D', 'position': 'Anywhere', 'classification': 'Post-translational', 'note': 'Rare'}, {'hidden': False, 'spec_group': 2, 'site': 'Y', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': False, 'spec_group': 1, 'site': 'T', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': False, 'spec_group': 1, 'site': 'S', 'position': 'Anywhere', 'classification': 'Post-translational'}], 'refs': [{'text': 'AA0036', 'source': 'RESID', 'url': None}, {'text': 'IonSource', 'source': 'Misc. URL', 'url': 'http://www.ionsource.com/Card/phos/phos.htm'}, {'text': 'AA0037', 'source': 'RESID', 'url': None}, {'text': 'AA0033', 'source': 'RESID', 'url': None}, {'text': 'AA0038', 'source': 'RESID', 'url': None}, {'text': 'AA0039', 'source': 'RESID', 'url': None}, {'text': 'AA0222', 'source': 'RESID', 'url': None}, {'text': 'PHOS', 'source': 'FindMod', 'url': None}, {'text': 'AA0034', 'source': 'RESID', 'url': None}, {'text': 'AA0035', 'source': 'RESID', 'url': None}]} stderr 2023-01-10 19:52:55.643 | DEBUG | ms2ml.proforma_utils:mod_id_mass:117 - Resolving mod_id: 7 stderr 2023-01-10 19:52:55.644 | DEBUG | ms2ml.proforma_utils:mod_id_mass:119 - Resolved to {'date_time_modified': datetime.datetime(2018, 10, 25, 9, 32, 26), 'date_time_posted': datetime.datetime(2002, 8, 19, 19, 17, 11), 'avge_mass': 0.9848, 'mono_mass': 0.984016, 'composition': Composition({'H': -1, 'N': -1, 'O': 1}), 'record_id': 7, 'approved': False, 'title': 'Deamidated', 'full_name': 'Deamidation', 'username_of_poster': 'unimod', 'group_of_poster': 'admin', 'specificity': [{'hidden': False, 'spec_group': 1, 'site': 'Q', 'position': 'Anywhere', 'classification': 'Artefact'}, {'hidden': True, 'spec_group': 2, 'site': 'R', 'position': 'Anywhere', 'classification': 'Post-translational', 'note': 'Protein which is post-translationally modified by the de-imination of one or more arginine residues; Peptidylarginine deiminase (PAD) converts protein bound to citrulline'}, {'hidden': False, 'spec_group': 1, 'site': 'N', 'position': 'Anywhere', 'classification': 'Artefact', 'note': 'Convertion of glycosylated asparagine residues upon deglycosylation with PNGase F in H2O'}, {'hidden': True, 'spec_group': 3, 'site': 'F', 'position': 'Protein N-term', 'classification': 'Post-translational'}], 'alt_names': ['phenyllactyl from N-term Phe', 'Citrullination'], 'refs': [{'text': '6838602', 'source': 'PubMed PMID', 'url': None}, {'text': 'AA0214', 'source': 'RESID', 'url': None}, {'text': 'IonSource tutorial', 'source': 'Misc. URL', 'url': 'http://www.ionsource.com/Card/Deamidation/deamidation.htm'}, {'text': 'CITR', 'source': 'FindMod', 'url': None}, {'text': 'AA0128', 'source': 'RESID', 'url': None}, {'text': 'FLAC', 'source': 'FindMod', 'url': None}, {'text': '15700232', 'source': 'PubMed PMID', 'url': None}, {'text': 'DEAM', 'source': 'FindMod', 'url': None}]} stderr 2023-01-10 19:52:55.646 | DEBUG | ms2ml.proforma_utils:mod_id_mass:117 - Resolving mod_id: 1 stderr 2023-01-10 19:52:55.647 | DEBUG | ms2ml.proforma_utils:mod_id_mass:119 - Resolved to {'date_time_modified': datetime.datetime(2017, 11, 8, 16, 8, 56), 'date_time_posted': datetime.datetime(2002, 8, 19, 19, 17, 11), 'avge_mass': 42.0367, 'mono_mass': 42.010565, 'composition': Composition({'H': 2, 'C': 2, 'O': 1}), 'record_id': 1, 'approved': True, 'title': 'Acetyl', 'full_name': 'Acetylation', 'username_of_poster': 'unimod', 'group_of_poster': 'admin', 'specificity': [{'hidden': True, 'spec_group': 6, 'site': 'T', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': False, 'spec_group': 5, 'site': 'N-term', 'position': 'Protein N-term', 'classification': 'Post-translational'}, {'hidden': True, 'spec_group': 4, 'site': 'S', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': True, 'spec_group': 3, 'site': 'C', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': False, 'spec_group': 2, 'site': 'N-term', 'position': 'Any N-term', 'classification': 'Multiple', 'note': 'GIST acetyl light'}, {'hidden': False, 'spec_group': 1, 'site': 'K', 'position': 'Anywhere', 'classification': 'Multiple', 'note': 'PT and GIST acetyl light'}, {'hidden': True, 'spec_group': 7, 'site': 'Y', 'position': 'Anywhere', 'classification': 'Chemical derivative', 'note': 'O-acetyl'}, {'hidden': True, 'spec_group': 8, 'site': 'H', 'position': 'Anywhere', 'classification': 'Chemical derivative'}, {'hidden': True, 'spec_group': 9, 'site': 'R', 'position': 'Anywhere', 'classification': 'Artefact', 'note': 'glyoxal-derived hydroimidazolone'}], 'refs': [{'text': 'AA0048', 'source': 'RESID', 'url': None}, {'text': 'AA0049', 'source': 'RESID', 'url': None}, {'text': 'AA0041', 'source': 'RESID', 'url': None}, {'text': 'AA0052', 'source': 'RESID', 'url': None}, {'text': 'AA0364', 'source': 'RESID', 'url': None}, {'text': 'AA0056', 'source': 'RESID', 'url': None}, {'text': 'AA0046', 'source': 'RESID', 'url': None}, {'text': 'AA0051', 'source': 'RESID', 'url': None}, {'text': 'AA0045', 'source': 'RESID', 'url': None}, {'text': 'AA0354', 'source': 'RESID', 'url': None}, {'text': 'AA0044', 'source': 'RESID', 'url': None}, {'text': 'AA0043', 'source': 'RESID', 'url': None}, {'text': '11999733', 'source': 'PubMed PMID', 'url': None}, {'text': 'Chemical Reagents for Protein Modification 3rd edition, pp 215-221, Roger L. Lundblad, CRC Press, New York, N.Y., 2005', 'source': 'Book', 'url': None}, {'text': 'IonSource acetylation tutorial', 'source': 'Misc. URL', 'url': 'http://www.ionsource.com/Card/acetylation/acetylation.htm'}, {'text': 'AA0055', 'source': 'RESID', 'url': None}, {'text': '14730666', 'source': 'PubMed PMID', 'url': None}, {'text': '15350136', 'source': 'PubMed PMID', 'url': None}, {'text': 'AA0047', 'source': 'RESID', 'url': None}, {'text': '12175151', 'source': 'PubMed PMID', 'url': None}, {'text': '11857757', 'source': 'PubMed PMID', 'url': None}, {'text': 'AA0042', 'source': 'RESID', 'url': None}, {'text': 'AA0050', 'source': 'RESID', 'url': None}, {'text': 'AA0053', 'source': 'RESID', 'url': None}, {'text': 'AA0054', 'source': 'RESID', 'url': None}, {'text': 'ACET', 'source': 'FindMod', 'url': None}, {'text': 'PNAS 2006 103: 18574-18579', 'source': 'Journal', 'url': 'http://dx.doi.org/10.1073/pnas.0608995103'}]} Display array([200., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], dtype=float32) print ( \"First 5: \" , spectrum . fragment_labels [: 5 ]) print ( \"Last 5:\" , spectrum . fragment_labels [ - 5 :]) print ( \"Total Number:\" , len ( spectrum . fragment_labels )) output First 5: ['y1^1', 'y1^2', 'y2^1', 'y2^2', 'y3^1'] Last 5: ['b28^2', 'b29^1', 'b29^2', 'b30^1', 'b30^2'] Total Number: 120 Modifying the encoding schema random_config = Config ( ion_series = 'zc' , ion_charges = ( 1 ,)) spectrum . config = random_config print ( spectrum . encode_fragments ()) print ( \"First 5: \" , spectrum . fragment_labels [: 5 ]) print ( \"Last 5:\" , spectrum . fragment_labels [ - 5 :]) print ( \"Total Number:\" , len ( spectrum . fragment_labels )) output [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] First 5: ['z1^1', 'z2^1', 'z3^1', 'z4^1', 'z5^1'] Last 5: ['c26^1', 'c27^1', 'c28^1', 'c29^1', 'c30^1'] Total Number: 60","title":"Encodings to tensors"},{"location":"encoding_options/#encodings-to-tensors","text":"When getting the data into your model, you usually will have to process it to some form of structured numeric input. There is a plethora fo ways to encode information. And I will show a couple (and how to get them using ms2ml)","title":"Encodings to tensors"},{"location":"encoding_options/#encoding-peptides","text":"import numpy as np from ms2ml.peptide import Peptide p = Peptide . from_sequence ( \"MYPEPTIDE\" ) print ( p ) output Peptide.from_sequence('MYPEPTIDE') stderr /home/runner/work/ms2ml/ms2ml/ms2ml/config.py:392: UserWarning: Using default config. Consider creating your own. warnings.warn(\"Using default config. Consider creating your own.\", UserWarning)","title":"Encoding Peptides"},{"location":"encoding_options/#counting","text":"count = p . aa_to_count () print ( count ) output [1 0 0 0 1 2 0 0 0 1 0 0 0 1 0 0 2 0 0 0 1 0 0 0 0 1 0 1 0]","title":"Counting"},{"location":"encoding_options/#one-hot-encoding","text":"oh = p . aa_to_onehot () # Note that there is an equivalent method for the modifications # p.mod_to_onehot() print ( oh ) output [[1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0]]","title":"One-hot encoding"},{"location":"encoding_options/#vectorizing","text":"vec = p . aa_to_vector () print ( vec ) output [ 0 13 25 16 5 16 20 9 4 5 27]","title":"Vectorizing"},{"location":"encoding_options/#encoding-spectra","text":"from ms2ml.spectrum import Spectrum from ms2ml.config import Config spectrum = Spectrum ( mz = np . array ([ 1000.0 , 1500.0 , 2000.0 ]), intensity = np . array ([ 1.0 , 2.0 , 3.0 ]), ms_level = 2 , precursor_mz = 1000.0 , ) print ( spectrum ) output Spectrum(mz=array([1000., 1500., 2000.]), intensity=array([1., 2., 3.]), ms_level=2, precursor_mz=1000.0, precursor_charge=None, instrument=None, analyzer=None, collision_energy=nan, activation=None, extras={}, retention_time=RetentionTime(rt=nan, units='seconds', run=None))","title":"Encoding Spectra"},{"location":"encoding_options/#binning","text":"binned = spectrum . bin_spectrum ( start = 500.0 , end = 1500.0 , binsize = 100.0 , # For the real world this would be 1 or 0.02 ... ) # or .... binned = spectrum . bin_spectrum ( start = 500.0 , end = 1500.0 , n_bins = 10 , ) print ( binned ) output [0. 0. 0. 0. 1. 0. 0. 0. 2.] # or .... binned = spectrum . bin_spectrum ( start = - 500.0 , end = + 500.0 , binsize = 100.0 , relative = True , # Will make all bins relative to the precursor mz ) # or .... binned = spectrum . bin_spectrum ( start = - 500.0 , end = + 500.0 , binsize = 100.0 , relative = 600 , # Will make all bins relative to 600! get_breaks = True ) binned_spectrum , bin_breaks = binned print ( binned_spectrum ) print ( bin_breaks ) output [0. 0. 1. 0. 0. 0. 0. 2. 0.] [ 100. 211.11111111 322.22222222 433.33333333 544.44444444 655.55555556 766.66666667 877.77777778 988.88888889 1100. ]","title":"Binning"},{"location":"encoding_options/#encoding-annotated-spectra","text":"from ms2ml.spectrum import AnnotatedPeptideSpectrum config = Config () peptide = Peptide . from_sequence ( \"PEPPINK/2\" , config ) spectrum = AnnotatedPeptideSpectrum ( mz = np . array ([ 50.0 , 147.11333 , 1000.0 , 1500.0 , 2000.0 ]), intensity = np . array ([ 50.0 , 200.0 , 1.0 , 2.0 , 3.0 ]), ms_level = 2 , precursor_peptide = peptide , precursor_mz = 147.11333 , ) spectrum print ( spectrum ) output AnnotatedPeptideSpectrum(mz=array([ 50. , 147.11333, 1000. , 1500. , 2000. ]), intensity=array([ 50., 200., 1., 2., 3.]), ms_level=2, precursor_mz=147.11333, precursor_charge=2, instrument=None, analyzer=None, collision_energy=nan, activation=None, extras={}, retention_time=RetentionTime(rt=nan, units='seconds', run=None), precursor_peptide=Peptide([('P', None), ('E', None), ('P', None), ('P', None), ('I', None), ('N', None), ('K', None)], {'n_term': None, 'c_term': None, 'unlocalized_modifications': [], 'labile_modifications': [], 'fixed_modifications': [], 'intervals': [], 'isotopes': [], 'group_ids': [], 'charge_state': ChargeState(2, [])}), precursor_isotope=0) spectrum . encode_fragments () stderr 2023-01-10 19:52:55.189 | DEBUG | ms2ml.proforma_utils:mod_id_mass:117 - Resolving mod_id: 21 stderr 2023-01-10 19:52:55.190 | DEBUG | ms2ml.proforma_utils:solver:84 - Initializing UnimodResolver stderr 2023-01-10 19:52:55.642 | DEBUG | ms2ml.proforma_utils:mod_id_mass:119 - Resolved to {'date_time_modified': datetime.datetime(2018, 8, 13, 13, 42, 59), 'date_time_posted': datetime.datetime(2002, 8, 19, 19, 17, 11), 'avge_mass': 79.9799, 'mono_mass': 79.966331, 'composition': Composition({'H': 1, 'O': 3, 'P': 1}), 'record_id': 21, 'approved': True, 'title': 'Phospho', 'full_name': 'Phosphorylation', 'username_of_poster': 'unimod', 'group_of_poster': 'admin', 'specificity': [{'hidden': True, 'spec_group': 8, 'site': 'E', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': True, 'spec_group': 6, 'site': 'R', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': True, 'spec_group': 7, 'site': 'K', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': True, 'spec_group': 4, 'site': 'H', 'position': 'Anywhere', 'classification': 'Post-translational', 'note': 'Rare'}, {'hidden': True, 'spec_group': 5, 'site': 'C', 'position': 'Anywhere', 'classification': 'Post-translational', 'note': 'Rare'}, {'hidden': True, 'spec_group': 3, 'site': 'D', 'position': 'Anywhere', 'classification': 'Post-translational', 'note': 'Rare'}, {'hidden': False, 'spec_group': 2, 'site': 'Y', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': False, 'spec_group': 1, 'site': 'T', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': False, 'spec_group': 1, 'site': 'S', 'position': 'Anywhere', 'classification': 'Post-translational'}], 'refs': [{'text': 'AA0036', 'source': 'RESID', 'url': None}, {'text': 'IonSource', 'source': 'Misc. URL', 'url': 'http://www.ionsource.com/Card/phos/phos.htm'}, {'text': 'AA0037', 'source': 'RESID', 'url': None}, {'text': 'AA0033', 'source': 'RESID', 'url': None}, {'text': 'AA0038', 'source': 'RESID', 'url': None}, {'text': 'AA0039', 'source': 'RESID', 'url': None}, {'text': 'AA0222', 'source': 'RESID', 'url': None}, {'text': 'PHOS', 'source': 'FindMod', 'url': None}, {'text': 'AA0034', 'source': 'RESID', 'url': None}, {'text': 'AA0035', 'source': 'RESID', 'url': None}]} stderr 2023-01-10 19:52:55.643 | DEBUG | ms2ml.proforma_utils:mod_id_mass:117 - Resolving mod_id: 7 stderr 2023-01-10 19:52:55.644 | DEBUG | ms2ml.proforma_utils:mod_id_mass:119 - Resolved to {'date_time_modified': datetime.datetime(2018, 10, 25, 9, 32, 26), 'date_time_posted': datetime.datetime(2002, 8, 19, 19, 17, 11), 'avge_mass': 0.9848, 'mono_mass': 0.984016, 'composition': Composition({'H': -1, 'N': -1, 'O': 1}), 'record_id': 7, 'approved': False, 'title': 'Deamidated', 'full_name': 'Deamidation', 'username_of_poster': 'unimod', 'group_of_poster': 'admin', 'specificity': [{'hidden': False, 'spec_group': 1, 'site': 'Q', 'position': 'Anywhere', 'classification': 'Artefact'}, {'hidden': True, 'spec_group': 2, 'site': 'R', 'position': 'Anywhere', 'classification': 'Post-translational', 'note': 'Protein which is post-translationally modified by the de-imination of one or more arginine residues; Peptidylarginine deiminase (PAD) converts protein bound to citrulline'}, {'hidden': False, 'spec_group': 1, 'site': 'N', 'position': 'Anywhere', 'classification': 'Artefact', 'note': 'Convertion of glycosylated asparagine residues upon deglycosylation with PNGase F in H2O'}, {'hidden': True, 'spec_group': 3, 'site': 'F', 'position': 'Protein N-term', 'classification': 'Post-translational'}], 'alt_names': ['phenyllactyl from N-term Phe', 'Citrullination'], 'refs': [{'text': '6838602', 'source': 'PubMed PMID', 'url': None}, {'text': 'AA0214', 'source': 'RESID', 'url': None}, {'text': 'IonSource tutorial', 'source': 'Misc. URL', 'url': 'http://www.ionsource.com/Card/Deamidation/deamidation.htm'}, {'text': 'CITR', 'source': 'FindMod', 'url': None}, {'text': 'AA0128', 'source': 'RESID', 'url': None}, {'text': 'FLAC', 'source': 'FindMod', 'url': None}, {'text': '15700232', 'source': 'PubMed PMID', 'url': None}, {'text': 'DEAM', 'source': 'FindMod', 'url': None}]} stderr 2023-01-10 19:52:55.646 | DEBUG | ms2ml.proforma_utils:mod_id_mass:117 - Resolving mod_id: 1 stderr 2023-01-10 19:52:55.647 | DEBUG | ms2ml.proforma_utils:mod_id_mass:119 - Resolved to {'date_time_modified': datetime.datetime(2017, 11, 8, 16, 8, 56), 'date_time_posted': datetime.datetime(2002, 8, 19, 19, 17, 11), 'avge_mass': 42.0367, 'mono_mass': 42.010565, 'composition': Composition({'H': 2, 'C': 2, 'O': 1}), 'record_id': 1, 'approved': True, 'title': 'Acetyl', 'full_name': 'Acetylation', 'username_of_poster': 'unimod', 'group_of_poster': 'admin', 'specificity': [{'hidden': True, 'spec_group': 6, 'site': 'T', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': False, 'spec_group': 5, 'site': 'N-term', 'position': 'Protein N-term', 'classification': 'Post-translational'}, {'hidden': True, 'spec_group': 4, 'site': 'S', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': True, 'spec_group': 3, 'site': 'C', 'position': 'Anywhere', 'classification': 'Post-translational'}, {'hidden': False, 'spec_group': 2, 'site': 'N-term', 'position': 'Any N-term', 'classification': 'Multiple', 'note': 'GIST acetyl light'}, {'hidden': False, 'spec_group': 1, 'site': 'K', 'position': 'Anywhere', 'classification': 'Multiple', 'note': 'PT and GIST acetyl light'}, {'hidden': True, 'spec_group': 7, 'site': 'Y', 'position': 'Anywhere', 'classification': 'Chemical derivative', 'note': 'O-acetyl'}, {'hidden': True, 'spec_group': 8, 'site': 'H', 'position': 'Anywhere', 'classification': 'Chemical derivative'}, {'hidden': True, 'spec_group': 9, 'site': 'R', 'position': 'Anywhere', 'classification': 'Artefact', 'note': 'glyoxal-derived hydroimidazolone'}], 'refs': [{'text': 'AA0048', 'source': 'RESID', 'url': None}, {'text': 'AA0049', 'source': 'RESID', 'url': None}, {'text': 'AA0041', 'source': 'RESID', 'url': None}, {'text': 'AA0052', 'source': 'RESID', 'url': None}, {'text': 'AA0364', 'source': 'RESID', 'url': None}, {'text': 'AA0056', 'source': 'RESID', 'url': None}, {'text': 'AA0046', 'source': 'RESID', 'url': None}, {'text': 'AA0051', 'source': 'RESID', 'url': None}, {'text': 'AA0045', 'source': 'RESID', 'url': None}, {'text': 'AA0354', 'source': 'RESID', 'url': None}, {'text': 'AA0044', 'source': 'RESID', 'url': None}, {'text': 'AA0043', 'source': 'RESID', 'url': None}, {'text': '11999733', 'source': 'PubMed PMID', 'url': None}, {'text': 'Chemical Reagents for Protein Modification 3rd edition, pp 215-221, Roger L. Lundblad, CRC Press, New York, N.Y., 2005', 'source': 'Book', 'url': None}, {'text': 'IonSource acetylation tutorial', 'source': 'Misc. URL', 'url': 'http://www.ionsource.com/Card/acetylation/acetylation.htm'}, {'text': 'AA0055', 'source': 'RESID', 'url': None}, {'text': '14730666', 'source': 'PubMed PMID', 'url': None}, {'text': '15350136', 'source': 'PubMed PMID', 'url': None}, {'text': 'AA0047', 'source': 'RESID', 'url': None}, {'text': '12175151', 'source': 'PubMed PMID', 'url': None}, {'text': '11857757', 'source': 'PubMed PMID', 'url': None}, {'text': 'AA0042', 'source': 'RESID', 'url': None}, {'text': 'AA0050', 'source': 'RESID', 'url': None}, {'text': 'AA0053', 'source': 'RESID', 'url': None}, {'text': 'AA0054', 'source': 'RESID', 'url': None}, {'text': 'ACET', 'source': 'FindMod', 'url': None}, {'text': 'PNAS 2006 103: 18574-18579', 'source': 'Journal', 'url': 'http://dx.doi.org/10.1073/pnas.0608995103'}]} Display array([200., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], dtype=float32) print ( \"First 5: \" , spectrum . fragment_labels [: 5 ]) print ( \"Last 5:\" , spectrum . fragment_labels [ - 5 :]) print ( \"Total Number:\" , len ( spectrum . fragment_labels )) output First 5: ['y1^1', 'y1^2', 'y2^1', 'y2^2', 'y3^1'] Last 5: ['b28^2', 'b29^1', 'b29^2', 'b30^1', 'b30^2'] Total Number: 120","title":"Encoding annotated spectra"},{"location":"encoding_options/#modifying-the-encoding-schema","text":"random_config = Config ( ion_series = 'zc' , ion_charges = ( 1 ,)) spectrum . config = random_config print ( spectrum . encode_fragments ()) print ( \"First 5: \" , spectrum . fragment_labels [: 5 ]) print ( \"Last 5:\" , spectrum . fragment_labels [ - 5 :]) print ( \"Total Number:\" , len ( spectrum . fragment_labels )) output [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] First 5: ['z1^1', 'z2^1', 'z3^1', 'z4^1', 'z5^1'] Last 5: ['c26^1', 'c27^1', 'c28^1', 'c29^1', 'c30^1'] Total Number: 60","title":"Modifying the encoding schema"},{"location":"ms2ml%20API/adapters/","text":"Adapters to ms data Spectral library adapters ms2ml . data . adapters . bibliospec . BiblioSpecAdapter ( file : str , config : Config , in_hook : Callable | None = None , out_hook : Callable | None = None , collate_fn : Callable = list ) Bases: BaseAdapter Implements an adapter that reads bibliospec files PARAMETER DESCRIPTION file Path to the bibliospec file TYPE: str config The config object TYPE: Config in_hook A function to apply to each element before processing. Defaults to None. TYPE: Callable DEFAULT: None out_hook A function to apply to each element after processing. Defaults to None. TYPE: Callable DEFAULT: None collate_fn A function to collate the elements. Defaults to list. TYPE: Callable DEFAULT: list Attributes ms2ml . data . adapters . bibliospec . BiblioSpecAdapter . parser = BiblioSpecParser ( file ) instance-attribute Functions ms2ml . data . adapters . bibliospec . BiblioSpecAdapter . parse () -> Iterator [ AnnotatedPeptideSpectrum ] ms2ml . data . adapters . bibliospec . BiblioSpecAdapter . parse_file ( file ) -> Iterator [ AnnotatedPeptideSpectrum ] ms2ml . data . adapters . encyclopedia . EncyclopeDIAAdapter ( file : str , config : Config , in_hook : Callable | None = None , out_hook : Callable | None = None , collate_fn : Callable = list ) Bases: BaseAdapter Implements an adapter that reads bibliospec files PARAMETER DESCRIPTION file Path to the .elib or .dlib file TYPE: str config The config object TYPE: Config in_hook A function to apply to each element before processing. Defaults to None. TYPE: Callable DEFAULT: None out_hook A function to apply to each element after processing. Defaults to None. TYPE: Callable DEFAULT: None collate_fn A function to collate the elements. Defaults to list. TYPE: Callable DEFAULT: list Attributes ms2ml . data . adapters . encyclopedia . EncyclopeDIAAdapter . parser = EncyclopeDIAParser ( file ) instance-attribute Functions ms2ml . data . adapters . encyclopedia . EncyclopeDIAAdapter . parse () -> Iterator [ AnnotatedPeptideSpectrum ] ms2ml . data . adapters . encyclopedia . EncyclopeDIAAdapter . parse_file ( file ) -> Iterator [ AnnotatedPeptideSpectrum ] ms2ml . data . adapters . msp . MSPAdapter ( config : Config , file : Optional [ str ] = None , in_hook : Optional [ Callable ] = None , out_hook : Optional [ Callable ] = None , collate_fn : Callable = pad_collate ) Bases: BaseAdapter Attributes ms2ml . data . adapters . msp . MSPAdapter . parser = MSPParser ( file ) instance-attribute Functions ms2ml . data . adapters . msp . MSPAdapter . parse_text ( text ) -> Iterator [ AnnotatedPeptideSpectrum ] ms2ml . data . adapters . msp . MSPAdapter . parse () -> Iterator [ AnnotatedPeptideSpectrum ] ms2ml . data . adapters . msp . MSPAdapter . parse_file ( file ) -> Iterator [ AnnotatedPeptideSpectrum ] ms2ml . data . adapters . msp . MSPAdapter . batch ( batch_size : int ) -> Iterator [ AnnotatedPeptideSpectrum ] ms2ml . data . adapters . pin . PinAdapter ( file : PathLike [ Any ], config : Config , in_hook : Callable | None = None , out_hook : Callable | None = None , collate_fn : Callable [ ... , Any ] | None = None , raw_file_locations : list [ PathLike ] | None = None ) Bases: PinParser , BaseAdapter Provides an adapter for pin files. PARAMETER DESCRIPTION file Path to the file to be parsed. TYPE: PathLike [ Any ] config The config object to use. TYPE: Config in_hook A function to apply to the input of the adapter. Defaults to None. TYPE: Callable DEFAULT: None out_hook A function to apply to the output of the adapter. Defaults to None. TYPE: Callable DEFAULT: None collate_fn A function to use to collate the output of the adapter. Defaults to pad_collate. TYPE: Callable [..., Any ] DEFAULT: None raw_file_locations A list of locations to search for raw files, if none is provided, attempts to find the files recursively in the current working directory. Defaults to None. TYPE: list [ PathLike ] DEFAULT: None Attributes ms2ml . data . adapters . pin . PinAdapter . mzml_adapters = {} instance-attribute ms2ml . data . adapters . pin . PinAdapter . raw_file_locations = [ '.' ] instance-attribute Functions ms2ml . data . adapters . pin . PinAdapter . parse_file ( file : PathLike [ Any ]) -> Iterator [ AnnotatedPeptideSpectrum ] Parses a pin file and yields one spectrum at a time. The spectra are yielded as AnnotatedPeptideSpectrum ms2ml . data . adapters . mokapot . MokapotPSMAdapter ( file : PathLike , config : Config , in_hook : Callable | None = None , out_hook : Callable | None = None , collate_fn : Callable [ ... , Any ] | None = None , raw_file_locations : list [ PathLike ] | PathLike = '.' ) Bases: BaseAdapter , MokapotPSMParser Attributes ms2ml . data . adapters . mokapot . MokapotPSMAdapter . mzml_adapters = {} instance-attribute ms2ml . data . adapters . mokapot . MokapotPSMAdapter . raw_file_locations = [ '.' ] instance-attribute Functions ms2ml . data . adapters . mokapot . MokapotPSMAdapter . parse_file ( file : PathLike ) -> Iterator [ AnnotatedPeptideSpectrum ] Parses a pin file and yields one spectrum at a time. The spectra are yielded as AnnotatedPeptideSpectrum ms2ml . data . adapters . spectronaut . SpectronautAdapter ( config : Config , in_hook : Callable = None , out_hook : Callable = None , collate_fn : Callable [ ... , Any ] = None ) Bases: SpectronautLibraryParser , BaseAdapter Functions ms2ml . data . adapters . spectronaut . SpectronautAdapter . parse_file ( file ) -> Iterator [ AnnotatedPeptideSpectrum ] Peptide Adapters ms2ml . data . adapters . fasta . FastaAdapter ( file : PathLike , config : Config , only_unique : bool = True , enzyme : str = 'trypsin' , missed_cleavages : int = 2 , allow_modifications : bool = False , in_hook : Callable | None = None , out_hook : Callable | None = None , collate_fn : Callable = list ) Bases: BaseAdapter , FastaDataset Implements an adapter that reads fasta files PARAMETER DESCRIPTION file Path to the fasta file TYPE: str config The config object TYPE: Config only_unique Whether to only keep unique peptides. Defaults to True. TYPE: bool DEFAULT: True enzyme The enzyme to use. Defaults to \"trypsin\". TYPE: str DEFAULT: 'trypsin' missed_cleavages The number of missed cleavages. Defaults to 2. TYPE: int DEFAULT: 2 in_hook A function to apply to each element before processing. Defaults to None. TYPE: Callable DEFAULT: None out_hook A function to apply to each element after processing. Defaults to None. TYPE: Callable DEFAULT: None collate_fn A function to collate the elements. Defaults to list. TYPE: Callable DEFAULT: list Attributes ms2ml . data . adapters . fasta . FastaAdapter . allow_modifications = allow_modifications instance-attribute Functions ms2ml . data . adapters . fasta . FastaAdapter . parse () -> Iterator [ Peptide ] MS data adapters ms2ml . data . adapters . mzml . MZMLAdapter ( file , config : Config , out_hook : Optional [ Callable ] = None , in_hook : Optional [ Callable ] = None , collate_fn : Callable = pad_collate ) Bases: BaseAdapter Provides an adapter for mzML files. PARAMETER DESCRIPTION file Path to the file to be parsed. TYPE: str config The config object to use. TYPE: Config out_hook A function to apply to the output of the adapter. Defaults to None. TYPE: Optional [ Callable ] DEFAULT: None in_hook A function to apply to the input of the adapter. Defaults to None. TYPE: Optional [ Callable ] DEFAULT: None collate_fn A function to use to collate the output of the adapter. Defaults to pad_collate. TYPE: Callable DEFAULT: pad_collate Attributes ms2ml . data . adapters . mzml . MZMLAdapter . file = str ( file ) instance-attribute ms2ml . data . adapters . mzml . MZMLAdapter . config = config instance-attribute ms2ml . data . adapters . mzml . MZMLAdapter . out_hook = out_hook instance-attribute ms2ml . data . adapters . mzml . MZMLAdapter . reader = read_mzml ( self . file , use_index = True , huge_tree = True ) instance-attribute ms2ml . data . adapters . mzml . MZMLAdapter . instrument = list ( instrument_data . values ())[ 0 ] instance-attribute Functions ms2ml . data . adapters . mzml . MZMLAdapter . parse () -> Generator [ Spectrum , None , None ] Parse the file and yield the spectra. RAISES DESCRIPTION NotImplementedError If the file contains a spectrum that is not centroided. Examples: adapter = MZMLAdapter(\"tests/data/BSA1.mzML\") for spec in adapter.parse(): print(spec) ms2ml . data . adapters . mzml . MZMLAdapter . parse_ms1 () -> Generator [ Spectrum , None , None ] Parse the file and yield the MS1 spectra. Examples: adapter = MZMLAdapter(\"tests/data/BSA1.mzML\") for spec in adapter.parse_ms1(): print(spec) ms2ml . data . adapters . mzml . MZMLAdapter . get_scan_info () -> pd . DataFrame ms2ml . data . adapters . mzml . MZMLAdapter . __repr__ () ms2ml . data . adapters . mzml . MZMLAdapter . __getitem__ ( idx ) cached","title":"Adapters to ms data"},{"location":"ms2ml%20API/adapters/#adapters-to-ms-data","text":"","title":"Adapters to ms data"},{"location":"ms2ml%20API/adapters/#spectral-library-adapters","text":"","title":"Spectral library adapters"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.bibliospec.BiblioSpecAdapter","text":"Bases: BaseAdapter Implements an adapter that reads bibliospec files PARAMETER DESCRIPTION file Path to the bibliospec file TYPE: str config The config object TYPE: Config in_hook A function to apply to each element before processing. Defaults to None. TYPE: Callable DEFAULT: None out_hook A function to apply to each element after processing. Defaults to None. TYPE: Callable DEFAULT: None collate_fn A function to collate the elements. Defaults to list. TYPE: Callable DEFAULT: list","title":"BiblioSpecAdapter"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.bibliospec.BiblioSpecAdapter-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.bibliospec.BiblioSpecAdapter.parser","text":"","title":"parser"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.bibliospec.BiblioSpecAdapter-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.bibliospec.BiblioSpecAdapter.parse","text":"","title":"parse()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.bibliospec.BiblioSpecAdapter.parse_file","text":"","title":"parse_file()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.encyclopedia.EncyclopeDIAAdapter","text":"Bases: BaseAdapter Implements an adapter that reads bibliospec files PARAMETER DESCRIPTION file Path to the .elib or .dlib file TYPE: str config The config object TYPE: Config in_hook A function to apply to each element before processing. Defaults to None. TYPE: Callable DEFAULT: None out_hook A function to apply to each element after processing. Defaults to None. TYPE: Callable DEFAULT: None collate_fn A function to collate the elements. Defaults to list. TYPE: Callable DEFAULT: list","title":"EncyclopeDIAAdapter"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.encyclopedia.EncyclopeDIAAdapter-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.encyclopedia.EncyclopeDIAAdapter.parser","text":"","title":"parser"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.encyclopedia.EncyclopeDIAAdapter-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.encyclopedia.EncyclopeDIAAdapter.parse","text":"","title":"parse()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.encyclopedia.EncyclopeDIAAdapter.parse_file","text":"","title":"parse_file()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.msp.MSPAdapter","text":"Bases: BaseAdapter","title":"MSPAdapter"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.msp.MSPAdapter-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.msp.MSPAdapter.parser","text":"","title":"parser"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.msp.MSPAdapter-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.msp.MSPAdapter.parse_text","text":"","title":"parse_text()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.msp.MSPAdapter.parse","text":"","title":"parse()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.msp.MSPAdapter.parse_file","text":"","title":"parse_file()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.msp.MSPAdapter.batch","text":"","title":"batch()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.pin.PinAdapter","text":"Bases: PinParser , BaseAdapter Provides an adapter for pin files. PARAMETER DESCRIPTION file Path to the file to be parsed. TYPE: PathLike [ Any ] config The config object to use. TYPE: Config in_hook A function to apply to the input of the adapter. Defaults to None. TYPE: Callable DEFAULT: None out_hook A function to apply to the output of the adapter. Defaults to None. TYPE: Callable DEFAULT: None collate_fn A function to use to collate the output of the adapter. Defaults to pad_collate. TYPE: Callable [..., Any ] DEFAULT: None raw_file_locations A list of locations to search for raw files, if none is provided, attempts to find the files recursively in the current working directory. Defaults to None. TYPE: list [ PathLike ] DEFAULT: None","title":"PinAdapter"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.pin.PinAdapter-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.pin.PinAdapter.mzml_adapters","text":"","title":"mzml_adapters"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.pin.PinAdapter.raw_file_locations","text":"","title":"raw_file_locations"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.pin.PinAdapter-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.pin.PinAdapter.parse_file","text":"Parses a pin file and yields one spectrum at a time. The spectra are yielded as AnnotatedPeptideSpectrum","title":"parse_file()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mokapot.MokapotPSMAdapter","text":"Bases: BaseAdapter , MokapotPSMParser","title":"MokapotPSMAdapter"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mokapot.MokapotPSMAdapter-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mokapot.MokapotPSMAdapter.mzml_adapters","text":"","title":"mzml_adapters"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mokapot.MokapotPSMAdapter.raw_file_locations","text":"","title":"raw_file_locations"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mokapot.MokapotPSMAdapter-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mokapot.MokapotPSMAdapter.parse_file","text":"Parses a pin file and yields one spectrum at a time. The spectra are yielded as AnnotatedPeptideSpectrum","title":"parse_file()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.spectronaut.SpectronautAdapter","text":"Bases: SpectronautLibraryParser , BaseAdapter","title":"SpectronautAdapter"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.spectronaut.SpectronautAdapter-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.spectronaut.SpectronautAdapter.parse_file","text":"","title":"parse_file()"},{"location":"ms2ml%20API/adapters/#peptide-adapters","text":"","title":"Peptide Adapters"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.fasta.FastaAdapter","text":"Bases: BaseAdapter , FastaDataset Implements an adapter that reads fasta files PARAMETER DESCRIPTION file Path to the fasta file TYPE: str config The config object TYPE: Config only_unique Whether to only keep unique peptides. Defaults to True. TYPE: bool DEFAULT: True enzyme The enzyme to use. Defaults to \"trypsin\". TYPE: str DEFAULT: 'trypsin' missed_cleavages The number of missed cleavages. Defaults to 2. TYPE: int DEFAULT: 2 in_hook A function to apply to each element before processing. Defaults to None. TYPE: Callable DEFAULT: None out_hook A function to apply to each element after processing. Defaults to None. TYPE: Callable DEFAULT: None collate_fn A function to collate the elements. Defaults to list. TYPE: Callable DEFAULT: list","title":"FastaAdapter"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.fasta.FastaAdapter-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.fasta.FastaAdapter.allow_modifications","text":"","title":"allow_modifications"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.fasta.FastaAdapter-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.fasta.FastaAdapter.parse","text":"","title":"parse()"},{"location":"ms2ml%20API/adapters/#ms-data-adapters","text":"","title":"MS data adapters"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter","text":"Bases: BaseAdapter Provides an adapter for mzML files. PARAMETER DESCRIPTION file Path to the file to be parsed. TYPE: str config The config object to use. TYPE: Config out_hook A function to apply to the output of the adapter. Defaults to None. TYPE: Optional [ Callable ] DEFAULT: None in_hook A function to apply to the input of the adapter. Defaults to None. TYPE: Optional [ Callable ] DEFAULT: None collate_fn A function to use to collate the output of the adapter. Defaults to pad_collate. TYPE: Callable DEFAULT: pad_collate","title":"MZMLAdapter"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter.file","text":"","title":"file"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter.config","text":"","title":"config"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter.out_hook","text":"","title":"out_hook"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter.reader","text":"","title":"reader"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter.instrument","text":"","title":"instrument"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter.parse","text":"Parse the file and yield the spectra. RAISES DESCRIPTION NotImplementedError If the file contains a spectrum that is not centroided. Examples: adapter = MZMLAdapter(\"tests/data/BSA1.mzML\") for spec in adapter.parse(): print(spec)","title":"parse()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter.parse_ms1","text":"Parse the file and yield the MS1 spectra. Examples: adapter = MZMLAdapter(\"tests/data/BSA1.mzML\") for spec in adapter.parse_ms1(): print(spec)","title":"parse_ms1()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter.get_scan_info","text":"","title":"get_scan_info()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter.__repr__","text":"","title":"__repr__()"},{"location":"ms2ml%20API/adapters/#ms2ml.data.adapters.mzml.MZMLAdapter.__getitem__","text":"","title":"__getitem__()"},{"location":"ms2ml%20API/configuration/","text":"Configuration object ms2ml.config Provides a place to define the project's configuration. Defines the constants that are used in the rest of the project. Such as the masses of aminoacids, supported modifications, length of the encodings, maximum length supported, labels and order of the encoded ions ... Attributes Classes ms2ml.config.Config dataclass General class to set and store the configuration of the project. Ideally every project will make one AND ONLY ONE of these. The provided defaults are meant to be reasonable for most projects but can be changed as needed. All annotation and endoding functionality should require one of this objects to work. PARAMETER DESCRIPTION g_tolerances A tuple of floats, where each float is the tolerance of that corresponding ms level. For instance (10, 20) means that the tolerance for ms1 is 10, 20 for ms2. TYPE: tuple [ float , ...] DEFAULT: (50, 50) g_tolerance_units A tuple of strings, that denote what tolerance unit to use for each ms level. For instance (\"ppm\", \"Da\") means that the tolerance for ms1 is in ppm, and for ms2 in Da. TYPE: tuple [ MassError , ...] DEFAULT: ('ppm', 'ppm') g_isotopes TYPE: tuple [ int , ...] DEFAULT: (0, 0) peptide_length_range A tuple of ints, where the first int is the minimum length of peptides. TYPE: tuple [ int , int ] DEFAULT: (5, 30) precursor_charges A tuple of ints, where each int is a possible precursor charge. TYPE: tuple [ int , ...] DEFAULT: (1, 2, 3, 4, 5, 6) fragment_positions A tuple of ints, where each int is a possible fragment position. TYPE: tuple [ int , ...] DEFAULT: tuple(range(1, 31)) ion_series A string of characters, where each character is a possible ion series. An example,a dn the default is ('by') TYPE: str DEFAULT: 'yb' ion_charges A tuple of ints, where each int is a possible ion charge. TYPE: tuple [ int , ...] DEFAULT: (1, 2) ion_neutral_losses TYPE: tuple [ str , ...] DEFAULT: () ion_encoding_nesting TYPE: tuple [ str , ...] DEFAULT: ('ion_charges', 'fragment_positions', 'ion_series') ion_naming_convention TYPE: str DEFAULT: '{ion_series}{fragment_positions}^{ion_charges}' mod_ambiguity_threshold TYPE: float DEFAULT: 0.99 mod_fixed_mods TYPE: tuple [ str ] DEFAULT: ('[UNIMOD:4]@C') Examples: >>> config = Config () >>> config Config(g_tolerances=(50, 50), ...) >>> config . fragment_labels ['y1^1', 'y1^2', ... 'b30^2'] Attributes g_tolerances : tuple [ float , ... ] = ( 50 , 50 ) class-attribute g_tolerance_units : tuple [ MassError , ... ] = ( 'ppm' , 'ppm' ) class-attribute g_isotopes : tuple [ int , ... ] = ( 0 , 0 ) class-attribute peptide_length_range : tuple [ int , int ] = ( 5 , 30 ) class-attribute peptide_mz_range : tuple [ float , float ] = ( 200 , 20000 ) class-attribute precursor_charges : tuple [ int , ... ] = ( 1 , 2 , 3 , 4 , 5 , 6 ) class-attribute fragment_positions : tuple [ int , ... ] = tuple ( range ( 1 , 31 )) class-attribute ion_series : str = 'yb' class-attribute ion_charges : tuple [ int , ... ] = ( 1 , 2 ) class-attribute ion_neutral_losses : tuple [ str , ... ] = () class-attribute ion_encoding_nesting : tuple [ str , ... ] = ( 'ion_charges' , 'fragment_positions' , 'ion_series' ) class-attribute ion_naming_convention : str = ' {ion_series}{fragment_positions} ^ {ion_charges} ' class-attribute mod_mode : ModModes = 'unimod' class-attribute mod_ambiguity_threshold : float = 0.99 class-attribute mod_fixed_mods : tuple [ str ] = ( '[UNIMOD:4]@C' ) class-attribute mod_variable_mods : dict [ str , tuple [ str ]] = field ( default_factory = _default_var_mods ) class-attribute encoding_aa_order : tuple [ str ] = tuple ([ 'n_term' ] + list ( string . ascii_uppercase ) + [ 'c_term' , '__missing__' ]) class-attribute encoding_mod_order : tuple [ str | None , ... ] = field ( default_factory = _default_mod_order ) class-attribute encoding_mod_alias : dict [ str , str ] = field ( default_factory = _default_mod_aliases ) class-attribute encoding_spec_bin_start : float = field ( repr = False , default = 0.0 ) class-attribute encoding_spec_bin_end : float = field ( repr = False , default = 2000.0 ) class-attribute encoding_spec_bin_binsize : float | None = field ( repr = False , default = 0.1 ) class-attribute encoding_spec_bin_n_bins : int | None = field ( repr = False , default = None ) class-attribute encoding_spec_bin_relative : bool = field ( repr = False , default = False ) class-attribute encoding_spec_bin_offset : float = field ( repr = False , default = 0.0 ) class-attribute num_fragment_embeddings : int property Functions fragment_labels () -> list [ str ] Returns a list of the labels that are used to encode the fragments. Examples: >>> config = Config () >>> config . fragment_labels ['y1^1', 'y1^2', ... 'b30^2'] ion_labeller ( ion : AnnotatedIon ) -> str Labels an ion Provided an ion, returns the label for that ion. Examples: >>> ion = AnnotatedIon ( mass = 123.2 , charge = 2 , position = 3 , ion_series = \"z\" ) >>> config = Config () >>> config . ion_labeller ( ion ) 'z3^2' aa_masses () mod_masses () encoding_mod_order_mapping () -> dict [ str | None , int ] encoding_aa_order_mapping () -> dict [ str | None , int ] asdict () Returns a dictionary representation of the config. to_toml ( path : str ) Writes the config to a toml file. from_toml ( path : str ) staticmethod Loads a config from a toml file. from_comet ( path : str , * args , ** kwargs ) Loads a config from a comet params file. ms2ml.config.ConfigNotSetError Bases: Exception Raised when a config is not set but is required. Functions ms2ml . config . get_default_config () -> Config","title":"Configuration object"},{"location":"ms2ml%20API/configuration/#configuration-object","text":"","title":"Configuration object"},{"location":"ms2ml%20API/configuration/#ms2ml.config","text":"Provides a place to define the project's configuration. Defines the constants that are used in the rest of the project. Such as the masses of aminoacids, supported modifications, length of the encodings, maximum length supported, labels and order of the encoded ions ...","title":"config"},{"location":"ms2ml%20API/configuration/#ms2ml.config-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/configuration/#ms2ml.config-classes","text":"","title":"Classes"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config","text":"General class to set and store the configuration of the project. Ideally every project will make one AND ONLY ONE of these. The provided defaults are meant to be reasonable for most projects but can be changed as needed. All annotation and endoding functionality should require one of this objects to work. PARAMETER DESCRIPTION g_tolerances A tuple of floats, where each float is the tolerance of that corresponding ms level. For instance (10, 20) means that the tolerance for ms1 is 10, 20 for ms2. TYPE: tuple [ float , ...] DEFAULT: (50, 50) g_tolerance_units A tuple of strings, that denote what tolerance unit to use for each ms level. For instance (\"ppm\", \"Da\") means that the tolerance for ms1 is in ppm, and for ms2 in Da. TYPE: tuple [ MassError , ...] DEFAULT: ('ppm', 'ppm') g_isotopes TYPE: tuple [ int , ...] DEFAULT: (0, 0) peptide_length_range A tuple of ints, where the first int is the minimum length of peptides. TYPE: tuple [ int , int ] DEFAULT: (5, 30) precursor_charges A tuple of ints, where each int is a possible precursor charge. TYPE: tuple [ int , ...] DEFAULT: (1, 2, 3, 4, 5, 6) fragment_positions A tuple of ints, where each int is a possible fragment position. TYPE: tuple [ int , ...] DEFAULT: tuple(range(1, 31)) ion_series A string of characters, where each character is a possible ion series. An example,a dn the default is ('by') TYPE: str DEFAULT: 'yb' ion_charges A tuple of ints, where each int is a possible ion charge. TYPE: tuple [ int , ...] DEFAULT: (1, 2) ion_neutral_losses TYPE: tuple [ str , ...] DEFAULT: () ion_encoding_nesting TYPE: tuple [ str , ...] DEFAULT: ('ion_charges', 'fragment_positions', 'ion_series') ion_naming_convention TYPE: str DEFAULT: '{ion_series}{fragment_positions}^{ion_charges}' mod_ambiguity_threshold TYPE: float DEFAULT: 0.99 mod_fixed_mods TYPE: tuple [ str ] DEFAULT: ('[UNIMOD:4]@C') Examples: >>> config = Config () >>> config Config(g_tolerances=(50, 50), ...) >>> config . fragment_labels ['y1^1', 'y1^2', ... 'b30^2']","title":"Config"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.g_tolerances","text":"","title":"g_tolerances"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.g_tolerance_units","text":"","title":"g_tolerance_units"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.g_isotopes","text":"","title":"g_isotopes"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.peptide_length_range","text":"","title":"peptide_length_range"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.peptide_mz_range","text":"","title":"peptide_mz_range"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.precursor_charges","text":"","title":"precursor_charges"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.fragment_positions","text":"","title":"fragment_positions"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.ion_series","text":"","title":"ion_series"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.ion_charges","text":"","title":"ion_charges"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.ion_neutral_losses","text":"","title":"ion_neutral_losses"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.ion_encoding_nesting","text":"","title":"ion_encoding_nesting"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.ion_naming_convention","text":"","title":"ion_naming_convention"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.mod_mode","text":"","title":"mod_mode"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.mod_ambiguity_threshold","text":"","title":"mod_ambiguity_threshold"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.mod_fixed_mods","text":"","title":"mod_fixed_mods"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.mod_variable_mods","text":"","title":"mod_variable_mods"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_aa_order","text":"","title":"encoding_aa_order"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_mod_order","text":"","title":"encoding_mod_order"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_mod_alias","text":"","title":"encoding_mod_alias"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_spec_bin_start","text":"","title":"encoding_spec_bin_start"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_spec_bin_end","text":"","title":"encoding_spec_bin_end"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_spec_bin_binsize","text":"","title":"encoding_spec_bin_binsize"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_spec_bin_n_bins","text":"","title":"encoding_spec_bin_n_bins"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_spec_bin_relative","text":"","title":"encoding_spec_bin_relative"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_spec_bin_offset","text":"","title":"encoding_spec_bin_offset"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.num_fragment_embeddings","text":"","title":"num_fragment_embeddings"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.fragment_labels","text":"Returns a list of the labels that are used to encode the fragments. Examples: >>> config = Config () >>> config . fragment_labels ['y1^1', 'y1^2', ... 'b30^2']","title":"fragment_labels()"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.ion_labeller","text":"Labels an ion Provided an ion, returns the label for that ion. Examples: >>> ion = AnnotatedIon ( mass = 123.2 , charge = 2 , position = 3 , ion_series = \"z\" ) >>> config = Config () >>> config . ion_labeller ( ion ) 'z3^2'","title":"ion_labeller()"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.aa_masses","text":"","title":"aa_masses()"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.mod_masses","text":"","title":"mod_masses()"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_mod_order_mapping","text":"","title":"encoding_mod_order_mapping()"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.encoding_aa_order_mapping","text":"","title":"encoding_aa_order_mapping()"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.asdict","text":"Returns a dictionary representation of the config.","title":"asdict()"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.to_toml","text":"Writes the config to a toml file.","title":"to_toml()"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.from_toml","text":"Loads a config from a toml file.","title":"from_toml()"},{"location":"ms2ml%20API/configuration/#ms2ml.config.Config.from_comet","text":"Loads a config from a comet params file.","title":"from_comet()"},{"location":"ms2ml%20API/configuration/#ms2ml.config.ConfigNotSetError","text":"Bases: Exception Raised when a config is not set but is required.","title":"ConfigNotSetError"},{"location":"ms2ml%20API/configuration/#ms2ml.config-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/configuration/#ms2ml.config.get_default_config","text":"","title":"get_default_config()"},{"location":"ms2ml%20API/peptide/","text":"Peptide objects ms2ml.peptide Attributes Classes ms2ml . peptide . Peptide ( sequence , properties , config , extras ) -> None Bases: ProForma Represents a peptide sequence with modifications. Examples: >>> p = Peptide . from_sequence ( \"MYPEPTIDE\" ) >>> p . mass 1093.46377747225 >>> p = Peptide . from_sequence ( \"MYPEPTIDE/2\" ) >>> p . charge 2 >>> p = Peptide . from_sequence ( \"J\" ) >>> p . mass 131.09462866083 >>> p = Peptide . from_sequence ( \"X\" ) >>> p . mass 18.010564683699997 >>> p = Peptide . from_sequence ( \"Z\" ) Note that it does not throw an error ... it should ... >>> p . mass 18.010564683699997 Attributes config = config instance-attribute extras = extras instance-attribute stripped_sequence property Returns the stripped sequence of the peptide. Examples: >>> p = Peptide . from_sequence ( \"PEPTIDE\" ) >>> p . stripped_sequence 'PEPTIDE' >>> p = Peptide . from_sequence ( \"PEPTIDE/2\" ) >>> p . stripped_sequence 'PEPTIDE' >>> p = Peptide . from_sequence ( \"PEPM[Oxidation]ASDA\" ) >>> p . stripped_sequence 'PEPMASDA' ProForma property mz property Returns the mz of the peptide. mass_pyteomics : float property Returns the mass of the peptide. charge : int property fragment_masses : list property Functions pre_parse_mods ( seq , config ) -> str staticmethod Parse the modifications in the sequence. from_proforma_seq ( seq , config : Config | None = None , extras = None ) -> Peptide classmethod Generates a peptide from a proforma sequence. Examples: >>> p = Peptide . from_proforma_seq ( \"PEPTIDE\" ) >>> p . mass 799.3599640267099 >>> p = Peptide . from_proforma_seq ( \"PEPTIDE\" , extras = { \"test\" : 1 }) >>> p . extras {'test': 1} from_sequence ( * args , ** kwargs ) classmethod Alias for from_proforma_seq. from_ProForma ( proforma : ProForma , config , extras = None ) -> Peptide classmethod Creates a peptide from a pyteomics.proforma.ProForma object. Examples: >>> from pyteomics.proforma import ProForma , parse >>> config = Config () >>> seq , props = parse ( \"PEPTIDE\" ) >>> p = ProForma ( seq , props ) >>> p = Peptide . from_ProForma ( p , config ) >>> p . mass 799.3599 to_proforma () -> str Converts the peptide to a string following the proforma specifications. Examples: >>> p = Peptide . from_sequence ( \"AMC\" ) >>> p . to_proforma () '<[UNIMOD:4]@C>AMC' to_massdiff_seq () -> str Converts the peptide to a string following the massdiff specifications. Examples: >>> p = Peptide . from_sequence ( \"AMC\" ) >>> p . to_massdiff_seq () 'AMC[+57.021464]' >>> p = Peptide . from_sequence ( \"[UNIMOD:1]-AMC\" ) >>> p . to_massdiff_seq () 'A[+42.010565]MC[+57.021464]' validate () -> bool Validates the built peptide. Not yet implemented. mass () -> float Calculates the mass of a peptide Examples: >>> p = Peptide . from_sequence ( \"MYPEPTIDE\" ) >>> p . mass 1093.46377747225 __str__ () -> str __getitem__ ( i ) Slices a peptide Examples: >>> pep = Peptide . _sample () >>> pep . stripped_sequence 'PEPTIDEPINK' >>> foo = pep [: 2 ] >>> foo . stripped_sequence 'PE' __len__ () -> int Returns the length of the peptide sequence. ion_series ( ion_type : str , charge : int ) -> NDArray [ np . float32 ] Calculates all the masses of an ion type. Calculates the masses of all fragments of the peptide for a given ion type. and charge. Examples: >>> p = Peptide . from_sequence ( \"AMC\" ) >>> p . ion_series ( \"a\" , 1 ) array([ 44.05003, 175.0905 ], dtype=float32) annotated_ion_series ( ion_type : str , charge : int ) -> list [ AnnotatedIon ] Returns a list of annotated ions. Examples: >>> p = Peptide . from_sequence ( \"AMC\" ) >>> p . annotated_ion_series ( \"b\" , 1 ) [AnnotatedIon(mass=72.044945, charge=1, position=1, ion_series='b', intensity=0, neutral_loss=None), AnnotatedIon(mass=203.08542, charge=1, position=2, ion_series='b', intensity=0, neutral_loss=None)] ion_dict () -> dict [ str , AnnotatedIon ] Returns a dictionary of all ion series for the peptide. RAISES DESCRIPTION ValueError If peptide does not have a charge state. Examples: >>> p = Peptide . from_sequence ( \"PEPPINK/2\" ) >>> p . ion_dict {'y1^1': AnnotatedIon(mass=147.11334, ... charge=2, position=6, ion_series='b', intensity=0, neutral_loss=None)} >>> p . ion_dict [ \"y5^1\" ] . mass 568.34537 theoretical_ion_labels () -> np . ndarray theoretical_ion_masses () -> np . ndarray aa_to_onehot () Converts the peptide sequence to a one-hot encoding. Returns a binary array of shape (nterm + peptide_length + cterm, len(self.config.encoding_aa_order)) The positions along the second axis are the one-hot encoding of the aminoacid, matching the order of the encoding_aa_order argument in the config. For instance, if the peptide was \"ABA\" and the encoding_aa_order was [\"n_term\", \"A\", \"B\", \"c_term\"], the vector would be: [ [1, 0, 0, 0 ,0], [0, 1, 0, 0 ,0], [0, 0, 1, 0 ,0], [0, 1, 0, 0 ,0], [0, 0, 0, 0 ,1] ] Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) >>> foo . aa_to_onehot () array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]], dtype=int32) mod_to_onehot () Converts the peptide sequence to a one-hot encoding. Returns a binary array of shape (nterm + peptide_length + cterm, len(self.config.encoding_mod_order)) The positions along the second axis are the one-hot encoding of the aminoacid, matching the order of the encoding_mod_order argument in the config. For instance, if the peptide was \"AC\" and the encoding_mod_order was [None, \"[UNIMOD:4]\"], being [UNIMOD:4] carbamidomethyl, the vector would be: [ [1, 0], [1, 0], [0, 1], [1, 0], ] Note that the 3rd position shows up as modified due to the implicit carbamidomethylation of C. Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) >>> foo . mod_to_onehot () array([[1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0]], dtype=int32) decode_onehot ( config : Config , seq_onehot : np . ndarray , mod_onehot : np . ndarray | None = None ) -> Peptide staticmethod Decodes a one-hot encoded vector into a peptide sequence. Examples: >>> config = Config () >>> foo = Peptide . from_sequence ( \"AMC\" , config = config ) >>> onehot = foo . aa_to_onehot () >>> mod_onehot = foo . mod_to_onehot () >>> Peptide . decode_onehot ( config , onehot , mod_onehot ) Peptide([('A', None), ('M', None), ('C', [UnimodModification('4', None, None)])], {'n_term': None, 'c_term': None, 'unlocalized_modifications': [], 'labile_modifications': [], 'fixed_modifications': [ModificationRule(UnimodModification('4', None, None), ['C'])], 'intervals': [], 'isotopes': [], 'group_ids': [], 'charge_state': None}) decode_vector ( config : Config , seq : np . ndarray , mod : np . ndarray | None , charge : int | None = None ) -> Peptide staticmethod Decodes a one-hot encoded vector into a peptide sequence. Examples: >>> config = Config () >>> foo = Peptide . from_sequence ( \"AMC\" , config ) >>> foo . aa_to_vector () array([ 0, 1, 13, 3, 27]) >>> foo . mod_to_vector () # Default config has carbamido array([0, 0, 0, 1, 0]) >>> Peptide . decode_vector ( ... foo . config , foo . aa_to_vector (), foo . mod_to_vector () ... ) Peptide([('A', None), ('M', None), ('C', [UnimodModification('4', None, None)])], {'n_term': None, 'c_term': None, 'unlocalized_modifications': [], 'labile_modifications': [], 'fixed_modifications': [ModificationRule(UnimodModification('4', None, None), ['C'])], 'intervals': [], 'isotopes': [], 'group_ids': [], 'charge_state': None}) aa_to_count () Converts the peptide sequence to a one-hot encoding. Returns a binary array of shape (nterm + peptide_length + cterm, len(self.config.encoding_aa_order)) The positions along the second axis are the one-hot encoding of the aminoacid, matching the order of the encoding_aa_order argument in the config. For instance, if the peptide was \"ABA\" and the encoding_aa_order was [\"n_term\", \"A\", \"B\", \"C\", \"c_term\"], the vector would be: [1, 2, 1, 0 ,1], Examples: >>> foo = Peptide . from_sequence ( \"AAMC\" ) >>> foo . aa_to_count () array([1, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]) mod_to_count () aa_to_vector () Converts the peptide sequence to a vector encoding. Returns a binary array of length (nterm + peptide_length + cterm) The number in every positions corresponds to the matching the order of the encoding_aa_order argument in the config. For instance, if the peptide was \"ABA\" and the encoding_aa_order was [\"n_term\", \"A\", \"B\", \"c_term\"], the vector would be: [0, 1, 2, 1, 3] Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) >>> foo . aa_to_vector () array([ 0, 1, 13, 3, 27]) mod_seq () Returns the sequence of modifications mathhing the aminoacid positions Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) >>> foo . mod_seq [None, None, None, '[UNIMOD:4]', None] mod_to_vector () Converts modifications to vectors Converts the modifications peptide sequence to a vector encoding. Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) # Implicit Carbamido. >>> foo . mod_to_vector () array([0, 0, 0, 1, 0]) from_vector ( aa_vector : list [ int ], mod_vector , config : Config ) classmethod Converts vectors back to peptides. Examples: >>> foo = Peptide . from_vector ([ 0 , 1 , 13 , 3 , 27 ], [ 0 , 0 , 0 , 1 , 0 ], Config ()) >>> foo . to_proforma () '<[UNIMOD:4]@C>AMC' __iter__ () -> Iterator [ tuple [ str , list [ str ] | None ]] Iterates over the peptide sequence. YIELDS DESCRIPTION Iterator [ tuple [ str , list [ str ] | None]] (aa, mod) tuples Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) >>> [ x for x in foo ] [('n_term', None), ('A', None), ('M', None), ('C', ['[UNIMOD:4]']), ('c_term', None)] >>> foo = Peptide . from_sequence ( \"AMS[Phospho]C\" ) >>> [ x for x in foo ] [('n_term', None), ('A', None), ('M', None), ('S', ['[UNIMOD:21]']), ('C', ['[UNIMOD:4]']), ('c_term', None)] from_iter ( it , config : Config ) staticmethod Creates a peptide from an iterator of (aa, mod) tuples. Examples: >>> foo = Peptide . from_iter ( ... [ ... ( \"n_term\" , None ), ... ( \"A\" , None ), ... ( \"M\" , None ), ... ( \"C\" , [ \"[UNIMOD:4]\" ]), ... ( \"c_term\" , None ), ... ], ... config = Config (), ... ) >>> foo . to_proforma () '<[UNIMOD:4]@C>AMC[UNIMOD:4]' >>> foo = Peptide . _sample () >>> foo . to_proforma () '[UNIMOD:1]-PEPT[UNIMOD:21]IDEPINK' >>> elems = [ x for x in foo ] >>> foo = Peptide . from_iter ( elems , config = Config ()) >>> foo . to_proforma () '[UNIMOD:1]-PEPT[UNIMOD:21]IDEPINK' __iter_base () -> list [ tuple [ str , list [ str ] | None ]] get_mod_isoforms () -> list [ Peptide ] Returns a list of possible modifications isoforms of a peptide. Examples: >>> foo = Peptide . from_sequence ( \"AM[UNIMOD:35]AMK\" ) >>> out = foo . get_mod_isoforms () >>> sorted ([ x . to_proforma () for x in out ]) ['AMAM[UNIMOD:35]K', 'AM[UNIMOD:35]AMK'] get_variable_possible_mods () Returns a list of possible modifications for each aminoacid. Examples: >>> foo = Peptide . from_sequence ( \"AMAMK\" ) >>> out = foo . get_variable_possible_mods () >>> sorted ([ x . to_proforma () for x in out ]) ['AMAMK', 'AMAM[UNIMOD:35]K', 'AM[UNIMOD:35]AMK', 'AM[UNIMOD:35]AM[UNIMOD:35]K'] Functions","title":"Peptide objects"},{"location":"ms2ml%20API/peptide/#peptide-objects","text":"","title":"Peptide objects"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide","text":"","title":"peptide"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide-classes","text":"","title":"Classes"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide","text":"Bases: ProForma Represents a peptide sequence with modifications. Examples: >>> p = Peptide . from_sequence ( \"MYPEPTIDE\" ) >>> p . mass 1093.46377747225 >>> p = Peptide . from_sequence ( \"MYPEPTIDE/2\" ) >>> p . charge 2 >>> p = Peptide . from_sequence ( \"J\" ) >>> p . mass 131.09462866083 >>> p = Peptide . from_sequence ( \"X\" ) >>> p . mass 18.010564683699997 >>> p = Peptide . from_sequence ( \"Z\" ) Note that it does not throw an error ... it should ... >>> p . mass 18.010564683699997","title":"Peptide"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.config","text":"","title":"config"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.extras","text":"","title":"extras"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.stripped_sequence","text":"Returns the stripped sequence of the peptide. Examples: >>> p = Peptide . from_sequence ( \"PEPTIDE\" ) >>> p . stripped_sequence 'PEPTIDE' >>> p = Peptide . from_sequence ( \"PEPTIDE/2\" ) >>> p . stripped_sequence 'PEPTIDE' >>> p = Peptide . from_sequence ( \"PEPM[Oxidation]ASDA\" ) >>> p . stripped_sequence 'PEPMASDA'","title":"stripped_sequence"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.ProForma","text":"","title":"ProForma"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.mz","text":"Returns the mz of the peptide.","title":"mz"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.mass_pyteomics","text":"Returns the mass of the peptide.","title":"mass_pyteomics"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.charge","text":"","title":"charge"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.fragment_masses","text":"","title":"fragment_masses"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.pre_parse_mods","text":"Parse the modifications in the sequence.","title":"pre_parse_mods()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.from_proforma_seq","text":"Generates a peptide from a proforma sequence. Examples: >>> p = Peptide . from_proforma_seq ( \"PEPTIDE\" ) >>> p . mass 799.3599640267099 >>> p = Peptide . from_proforma_seq ( \"PEPTIDE\" , extras = { \"test\" : 1 }) >>> p . extras {'test': 1}","title":"from_proforma_seq()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.from_sequence","text":"Alias for from_proforma_seq.","title":"from_sequence()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.from_ProForma","text":"Creates a peptide from a pyteomics.proforma.ProForma object. Examples: >>> from pyteomics.proforma import ProForma , parse >>> config = Config () >>> seq , props = parse ( \"PEPTIDE\" ) >>> p = ProForma ( seq , props ) >>> p = Peptide . from_ProForma ( p , config ) >>> p . mass 799.3599","title":"from_ProForma()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.to_proforma","text":"Converts the peptide to a string following the proforma specifications. Examples: >>> p = Peptide . from_sequence ( \"AMC\" ) >>> p . to_proforma () '<[UNIMOD:4]@C>AMC'","title":"to_proforma()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.to_massdiff_seq","text":"Converts the peptide to a string following the massdiff specifications. Examples: >>> p = Peptide . from_sequence ( \"AMC\" ) >>> p . to_massdiff_seq () 'AMC[+57.021464]' >>> p = Peptide . from_sequence ( \"[UNIMOD:1]-AMC\" ) >>> p . to_massdiff_seq () 'A[+42.010565]MC[+57.021464]'","title":"to_massdiff_seq()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.validate","text":"Validates the built peptide. Not yet implemented.","title":"validate()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.mass","text":"Calculates the mass of a peptide Examples: >>> p = Peptide . from_sequence ( \"MYPEPTIDE\" ) >>> p . mass 1093.46377747225","title":"mass()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.__str__","text":"","title":"__str__()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.__getitem__","text":"Slices a peptide Examples: >>> pep = Peptide . _sample () >>> pep . stripped_sequence 'PEPTIDEPINK' >>> foo = pep [: 2 ] >>> foo . stripped_sequence 'PE'","title":"__getitem__()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.__len__","text":"Returns the length of the peptide sequence.","title":"__len__()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.ion_series","text":"Calculates all the masses of an ion type. Calculates the masses of all fragments of the peptide for a given ion type. and charge. Examples: >>> p = Peptide . from_sequence ( \"AMC\" ) >>> p . ion_series ( \"a\" , 1 ) array([ 44.05003, 175.0905 ], dtype=float32)","title":"ion_series()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.annotated_ion_series","text":"Returns a list of annotated ions. Examples: >>> p = Peptide . from_sequence ( \"AMC\" ) >>> p . annotated_ion_series ( \"b\" , 1 ) [AnnotatedIon(mass=72.044945, charge=1, position=1, ion_series='b', intensity=0, neutral_loss=None), AnnotatedIon(mass=203.08542, charge=1, position=2, ion_series='b', intensity=0, neutral_loss=None)]","title":"annotated_ion_series()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.ion_dict","text":"Returns a dictionary of all ion series for the peptide. RAISES DESCRIPTION ValueError If peptide does not have a charge state. Examples: >>> p = Peptide . from_sequence ( \"PEPPINK/2\" ) >>> p . ion_dict {'y1^1': AnnotatedIon(mass=147.11334, ... charge=2, position=6, ion_series='b', intensity=0, neutral_loss=None)} >>> p . ion_dict [ \"y5^1\" ] . mass 568.34537","title":"ion_dict()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.theoretical_ion_labels","text":"","title":"theoretical_ion_labels()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.theoretical_ion_masses","text":"","title":"theoretical_ion_masses()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.aa_to_onehot","text":"Converts the peptide sequence to a one-hot encoding. Returns a binary array of shape (nterm + peptide_length + cterm, len(self.config.encoding_aa_order)) The positions along the second axis are the one-hot encoding of the aminoacid, matching the order of the encoding_aa_order argument in the config. For instance, if the peptide was \"ABA\" and the encoding_aa_order was [\"n_term\", \"A\", \"B\", \"c_term\"], the vector would be: [ [1, 0, 0, 0 ,0], [0, 1, 0, 0 ,0], [0, 0, 1, 0 ,0], [0, 1, 0, 0 ,0], [0, 0, 0, 0 ,1] ] Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) >>> foo . aa_to_onehot () array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]], dtype=int32)","title":"aa_to_onehot()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.mod_to_onehot","text":"Converts the peptide sequence to a one-hot encoding. Returns a binary array of shape (nterm + peptide_length + cterm, len(self.config.encoding_mod_order)) The positions along the second axis are the one-hot encoding of the aminoacid, matching the order of the encoding_mod_order argument in the config. For instance, if the peptide was \"AC\" and the encoding_mod_order was [None, \"[UNIMOD:4]\"], being [UNIMOD:4] carbamidomethyl, the vector would be: [ [1, 0], [1, 0], [0, 1], [1, 0], ] Note that the 3rd position shows up as modified due to the implicit carbamidomethylation of C. Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) >>> foo . mod_to_onehot () array([[1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0]], dtype=int32)","title":"mod_to_onehot()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.decode_onehot","text":"Decodes a one-hot encoded vector into a peptide sequence. Examples: >>> config = Config () >>> foo = Peptide . from_sequence ( \"AMC\" , config = config ) >>> onehot = foo . aa_to_onehot () >>> mod_onehot = foo . mod_to_onehot () >>> Peptide . decode_onehot ( config , onehot , mod_onehot ) Peptide([('A', None), ('M', None), ('C', [UnimodModification('4', None, None)])], {'n_term': None, 'c_term': None, 'unlocalized_modifications': [], 'labile_modifications': [], 'fixed_modifications': [ModificationRule(UnimodModification('4', None, None), ['C'])], 'intervals': [], 'isotopes': [], 'group_ids': [], 'charge_state': None})","title":"decode_onehot()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.decode_vector","text":"Decodes a one-hot encoded vector into a peptide sequence. Examples: >>> config = Config () >>> foo = Peptide . from_sequence ( \"AMC\" , config ) >>> foo . aa_to_vector () array([ 0, 1, 13, 3, 27]) >>> foo . mod_to_vector () # Default config has carbamido array([0, 0, 0, 1, 0]) >>> Peptide . decode_vector ( ... foo . config , foo . aa_to_vector (), foo . mod_to_vector () ... ) Peptide([('A', None), ('M', None), ('C', [UnimodModification('4', None, None)])], {'n_term': None, 'c_term': None, 'unlocalized_modifications': [], 'labile_modifications': [], 'fixed_modifications': [ModificationRule(UnimodModification('4', None, None), ['C'])], 'intervals': [], 'isotopes': [], 'group_ids': [], 'charge_state': None})","title":"decode_vector()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.aa_to_count","text":"Converts the peptide sequence to a one-hot encoding. Returns a binary array of shape (nterm + peptide_length + cterm, len(self.config.encoding_aa_order)) The positions along the second axis are the one-hot encoding of the aminoacid, matching the order of the encoding_aa_order argument in the config. For instance, if the peptide was \"ABA\" and the encoding_aa_order was [\"n_term\", \"A\", \"B\", \"C\", \"c_term\"], the vector would be: [1, 2, 1, 0 ,1], Examples: >>> foo = Peptide . from_sequence ( \"AAMC\" ) >>> foo . aa_to_count () array([1, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0])","title":"aa_to_count()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.mod_to_count","text":"","title":"mod_to_count()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.aa_to_vector","text":"Converts the peptide sequence to a vector encoding. Returns a binary array of length (nterm + peptide_length + cterm) The number in every positions corresponds to the matching the order of the encoding_aa_order argument in the config. For instance, if the peptide was \"ABA\" and the encoding_aa_order was [\"n_term\", \"A\", \"B\", \"c_term\"], the vector would be: [0, 1, 2, 1, 3] Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) >>> foo . aa_to_vector () array([ 0, 1, 13, 3, 27])","title":"aa_to_vector()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.mod_seq","text":"Returns the sequence of modifications mathhing the aminoacid positions Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) >>> foo . mod_seq [None, None, None, '[UNIMOD:4]', None]","title":"mod_seq()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.mod_to_vector","text":"Converts modifications to vectors Converts the modifications peptide sequence to a vector encoding. Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) # Implicit Carbamido. >>> foo . mod_to_vector () array([0, 0, 0, 1, 0])","title":"mod_to_vector()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.from_vector","text":"Converts vectors back to peptides. Examples: >>> foo = Peptide . from_vector ([ 0 , 1 , 13 , 3 , 27 ], [ 0 , 0 , 0 , 1 , 0 ], Config ()) >>> foo . to_proforma () '<[UNIMOD:4]@C>AMC'","title":"from_vector()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.__iter__","text":"Iterates over the peptide sequence. YIELDS DESCRIPTION Iterator [ tuple [ str , list [ str ] | None]] (aa, mod) tuples Examples: >>> foo = Peptide . from_sequence ( \"AMC\" ) >>> [ x for x in foo ] [('n_term', None), ('A', None), ('M', None), ('C', ['[UNIMOD:4]']), ('c_term', None)] >>> foo = Peptide . from_sequence ( \"AMS[Phospho]C\" ) >>> [ x for x in foo ] [('n_term', None), ('A', None), ('M', None), ('S', ['[UNIMOD:21]']), ('C', ['[UNIMOD:4]']), ('c_term', None)]","title":"__iter__()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.from_iter","text":"Creates a peptide from an iterator of (aa, mod) tuples. Examples: >>> foo = Peptide . from_iter ( ... [ ... ( \"n_term\" , None ), ... ( \"A\" , None ), ... ( \"M\" , None ), ... ( \"C\" , [ \"[UNIMOD:4]\" ]), ... ( \"c_term\" , None ), ... ], ... config = Config (), ... ) >>> foo . to_proforma () '<[UNIMOD:4]@C>AMC[UNIMOD:4]' >>> foo = Peptide . _sample () >>> foo . to_proforma () '[UNIMOD:1]-PEPT[UNIMOD:21]IDEPINK' >>> elems = [ x for x in foo ] >>> foo = Peptide . from_iter ( elems , config = Config ()) >>> foo . to_proforma () '[UNIMOD:1]-PEPT[UNIMOD:21]IDEPINK'","title":"from_iter()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.__iter_base","text":"","title":"__iter_base()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.get_mod_isoforms","text":"Returns a list of possible modifications isoforms of a peptide. Examples: >>> foo = Peptide . from_sequence ( \"AM[UNIMOD:35]AMK\" ) >>> out = foo . get_mod_isoforms () >>> sorted ([ x . to_proforma () for x in out ]) ['AMAM[UNIMOD:35]K', 'AM[UNIMOD:35]AMK']","title":"get_mod_isoforms()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide.Peptide.get_variable_possible_mods","text":"Returns a list of possible modifications for each aminoacid. Examples: >>> foo = Peptide . from_sequence ( \"AMAMK\" ) >>> out = foo . get_variable_possible_mods () >>> sorted ([ x . to_proforma () for x in out ]) ['AMAMK', 'AMAM[UNIMOD:35]K', 'AM[UNIMOD:35]AMK', 'AM[UNIMOD:35]AM[UNIMOD:35]K']","title":"get_variable_possible_mods()"},{"location":"ms2ml%20API/peptide/#ms2ml.peptide-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/spectra/","text":"Spectrum objects ms2ml.spectrum Implements classes to represent spectra. This module implements classes to represent spectra and their annotations (when they have any). There are broadly two types of spectra: 1. General Spectra 2. Annotated Spectra Classes ms2ml.spectrum.Spectrum dataclass Class to store the spectrum information. Examples: >>> spectrum = Spectrum ( ... mz = np . array ([ 1000.0 , 1500.0 , 2000.0 ]), ... intensity = np . array ([ 1.0 , 2.0 , 3.0 ]), ... precursor_mz = 1000.0 , ... precursor_charge = 2 , ... ms_level = 2 , ... extras = { \"EXTRAS\" : [ \"extra1\" , \"extra2\" ]}, ... ) >>> spectrum Spectrum(mz=array([1000., 1500., 2000.]), ...) Attributes mz : NDArray [ np . float64 ] class-attribute intensity : NDArray [ np . float32 ] class-attribute ms_level : int class-attribute precursor_mz : float | None class-attribute precursor_charge : int | None = None class-attribute instrument : str | None = None class-attribute analyzer : str | None = None class-attribute collision_energy : float = field ( default = float ( 'nan' )) class-attribute activation : str | None = None class-attribute extras : dict = field ( default_factory = dict ) class-attribute retention_time : RetentionTime | float = field ( default_factory = lambda : RetentionTime ( rt = float ( 'nan' ), units = 'seconds' )) class-attribute config : Config = field ( repr = False , default_factory = get_default_config ) class-attribute Functions __post_init__ () replace ( * args : Any , ** kwargs : Any ) -> Spectrum Replaces the attributes of the spectrum with the given values. Arguments are passed to the class Spectrum constructor. RETURNS DESCRIPTION Spectrum Spectrum, A new Spectrum object with the replaced attributes. filter_top ( n : int ) -> Spectrum Filters the spectrum to the top n peaks. PARAMETER DESCRIPTION n The number of peaks to keep. TYPE: int RETURNS DESCRIPTION Spectrum The spectrum with the filtered top n peaks. Examples: >>> spectrum = Spectrum . _sample () >>> spectrum . intensity array([ 50., 200., 1., 2., 3.]) >>> spectrum . filter_top ( 2 ) . intensity array([ 50., 200.]) >>> Spectrum . _sample () . filter_top ( 3 ) . intensity array([ 3., 50., 200.]) filter_mz_range ( min_mz : float , max_mz : float ) -> Spectrum Filters the spectrum to a given m/z range. RETURNS DESCRIPTION Spectrum The spectrum with the filtered m/z range. Examples: >>> spectrum = Spectrum . _sample () >>> spectrum . mz array([ 50. , 147.11333, 1000. , 1500. , 2000. ]) >>> spectrum . tic 256.0 >>> spectrum = spectrum . filter_mz_range ( 124 , 1600 ) >>> spectrum . mz array([ 147.11333, 1000. , 1500. ]) >>> spectrum . filter_mz_range ( 124 , 1600 ) . tic 203.0 remove_precursor () -> Spectrum Removes the precursor peak from the spectrum RETURNS DESCRIPTION Spectrum Spectrum, A new Spectrum object with the precursor peak removed. intensity_cutoff ( cutoff : float ) -> Spectrum Filters the spectrum to a given intensity cutoff. PARAMETER DESCRIPTION cutoff The intensity cutoff. All peaks with less than that intensity will be deleted. TYPE: float RETURNS DESCRIPTION Spectrum A new Spectrum object with the filtered intensity cutoff. Examples: >>> spectrum = Spectrum . _sample () >>> spectrum . intensity array([ 50., 200., 1., 2., 3.]) >>> spectrum . intensity_cutoff ( 2.1 ) . intensity array([ 50.0, 200., 3.]) >>> spectrum . intensity array([ 50., 200., 1., 2., 3.]) normalize_intensity ( method : str = 'max' ) -> Spectrum Normalizes the spectrum intensities. PARAMETER DESCRIPTION method The method to use for normalization. Can be one of \"max\", \"sum\", \"rank\", \"log\". TYPE: str DEFAULT: 'max' RETURNS DESCRIPTION Spectrum The normalized spectrum. Examples: >>> spectrum = Spectrum . _sample () >>> spectrum . intensity array([ 50., 200., 1., 2., 3.]) >>> Spectrum . _sample () . normalize_intensity ( \"max\" ) . intensity array([0.25 , 1. , 0.005, 0.01 , 0.015]) >>> Spectrum . _sample () . normalize_intensity ( \"sum\" ) . intensity array([0.1953125 , 0.78125 , 0.00390625, 0.0078125 , 0.01171875]) >>> Spectrum . _sample () . normalize_intensity ( \"log\" ) . intensity array([3.91202301, 5.29831737, 0. , 0.69314718, 1.09861229]) >>> Spectrum . _sample () . normalize_intensity ( \"sqrt\" ) . intensity array([ 7.07106781, 14.14213562, 1. , 1.41421356, 1.73205081]) encode_spec_bins () -> NDArray [ np . float32 ] Encodes the spectrum into bins. For a version of this function that takes arguments indead of reading the options from the config, see Spectrum.bin_spectrum . Uses the following options from the config Config.encoding_spec_bin_start, Config.encoding_spec_bin_end, Config.encoding_spec_bin_n_bins, Config.encoding_spec_bin_binsize, Config.encoding_spec_bin_relative, Config.encoding_spec_bin_offset, RETURNS DESCRIPTION NDArray [ np . float32 ] The encoded spectrum. Examples: >>> Spectrum . _sample () . encode_spec_bins () . shape (19999,) bin_spectrum ( start : float , end : float , binsize : float | None = None , n_bins : int | None = None , relative : bool = False , offset : float = 0 , get_breaks : bool = False ) -> NDArray [ np . float32 ] | tuple [ NDArray [ np . float32 ], NDArray [ np . float64 ]] Bins the spectrum. PARAMETER DESCRIPTION start The start of the binning range. If missing will use the lowest mz value. TYPE: float end The end of the binning range. If missing will use the highest mz value. TYPE: float binsize The size of the bins. Cannot be used in conjunction with n_bins. TYPE: float | None DEFAULT: None n_bins The number of bins. Cannot be used in conjunction with binsize. TYPE: int | None DEFAULT: None relative Whether to use binning relative to the precursor mass. TYPE: bool DEFAULT: False offset The offset to use for relative binning. TYPE: float DEFAULT: 0 RETURNS DESCRIPTION NDArray [ np . float32 ] | tuple [ NDArray [ np . float32 ], NDArray [ np . float64 ]] An array of binned intensities. base_peak ( value ) -> None tic ( value ) -> None sic ( mzs : NDArray [ np . float32 ], resolution : Callable = sum ) -> NDArray [ np . float32 ] Returns the selected ion current for a given set of m/z values. PARAMETER DESCRIPTION mzs The m/z values to calculate the SIC for. TYPE: NDArray [ np . float32 ] resolution The function used to resolve ambiguities when multiple peaks match. possible options are sum and max . TYPE: Callable DEFAULT: sum RETURNS DESCRIPTION NDArray [ np . float32 ] An array of SIC values. This array will have the same length as the NDArray [ np . float32 ] input mzs array. Examples: >>> spectrum = Spectrum . _sample () >>> spectrum . mz array([ 50. , 147.11333, 1000. , 1500. , 2000. ]) >>> spectrum . intensity array([ 50., 200., 1., 2., 3.]) >>> spectrum . sic ( ... np . array ([ 1000.0 , 1000.00001 , 1500.0 , 2000.0 , 20_000.0 ]), ... resolution = sum , ... ) array([1., 1., 2., 3., 0.]) annotate ( peptide : str | Peptide ) -> AnnotatedPeptideSpectrum Annotates the spectrum with the given peptide. PARAMETER DESCRIPTION peptide The peptide to annotate the spectrum with. TYPE: str | Peptide RETURNS DESCRIPTION AnnotatedPeptideSpectrum An AnnotatedPeptideSpectrum object. Examples: >>> spectrum = Spectrum . _sample () >>> peptide = Peptide . from_sequence ( \"PEPPINK/2\" , spectrum . config ) >>> annotated_spectrum = spectrum . annotate ( peptide ) >>> annotated_spectrum AnnotatedPeptideSpectrum(mz=array([ 50. ... precursor_isotope=0) to_sus () plot ( ax = None , ** kwargs ) -> plt . Axes stack ( spectra : Iterable [ Spectrum ]) -> Spectrum classmethod Stacks multiple spectra into a single spectrum. PARAMETER DESCRIPTION spectra An iterable of spectra to stack. TYPE: Iterable [ Spectrum ] RETURNS DESCRIPTION Spectrum A stacked spectrum. Examples: >>> np . random . seed ( 0 ) >>> spectrum1 = Spectrum . _sample () >>> spectrum2 = Spectrum . _sample ( random = True ) >>> spectrum3 = Spectrum . _sample ( random = True ) >>> spectrum4 = Spectrum . _sample ( random = False ) >>> spectrum4 . mz = spectrum1 . mz + 1e-4 >>> mzs , ints = Spectrum . stack ([ spectrum1 , spectrum2 , spectrum3 , spectrum4 ]) >>> mzs array([ 50. , 147.11333 , 423.65479934, 437.58721126, 544.883183 , 592.84461823, 645.89411307, 1000. , 1500. , 2000. ]) >>> ints array([[ 50. , 0. , 0. , 50. ], [200. , 0. , 0. , 200. ], [ 0. , 0. , 963.6627605 , 0. ], [ 0. , 0. , 791.72503808, 0. ], [ 0. , 0. , 891.77300078, 0. ], [ 0. , 844.26574858, 0. , 0. ], [ 0. , 0. , 383.44151883, 0. ], [ 1. , 0. , 0. , 1. ], [ 2. , 0. , 0. , 2. ], [ 3. , 0. , 0. , 3. ]]) >>> ints . shape (10, 4) ms2ml.spectrum.AnnotatedPeptideSpectrum dataclass Bases: Spectrum Class to store the spectrum information. In combination with the peptide information, it can be used to annotate the spectrum. Examples: >>> config = Config () >>> peptide = Peptide . from_sequence ( \"PEPPINK/2\" , config ) >>> spectrum = AnnotatedPeptideSpectrum ( ... mz = np . array ([ 50.0 , 147.11333 , 1000.0 , 1500.0 , 2000.0 ]), ... intensity = np . array ([ 50.0 , 200.0 , 1.0 , 2.0 , 3.0 ]), ... ms_level = 2 , ... extras = { \"EXTRAS\" : [ \"extra1\" , \"extra2\" ]}, ... precursor_peptide = peptide , ... precursor_mz = 147.11333 , ... ) >>> spectrum AnnotatedPeptideSpectrum(mz=array([ 50. ... precursor_isotope=0) >>> spectrum . fragment_intensities {'y1^1': 200.0} >>> spectrum [ \"y1^1\" ] 200.0 >>> spectrum . fragments {'y1^1': AnnotatedIon(mass=147.11334, charge=1, position=1, ion_series='y', intensity=200.0, neutral_loss=None)} Attributes precursor_peptide : Peptide | None = None class-attribute precursor_isotope : int | None = 0 class-attribute precursor_charge : int | None = None class-attribute charge property mass_error property fragment_labels : list [ str ] property Encodes the fragment ions as a numpy array The order of the ions will be defined in the config file. Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> spec . fragment_labels ['y1^1', ...] Functions __post_init__ ( * args , ** kwargs ) fragment_intensities () -> dict [ str , float ] Returs a dictionary with the fragment ion names as keys and the corresponding intensities as values. Note The current implementation only keeps the last peak that matches the theoretical mass. future implementations should either keep all peaks or only the highest peak, or add the peaks. Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> spec . fragment_intensities {'y1^1': 200.0} fragments () -> dict [ str , AnnotatedIon ] Returs a dictionary with the fragment ion names as keys and the corresponding AnnotatedIon objects as values. Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> spec . fragments {'y1^1': AnnotatedIon(mass=147.11334, charge=1, position=1, ion_series='y', intensity=200.0, neutral_loss=None)} __getitem__ ( index ) -> float Returns the intensity of the fragment ion with the given name. Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> spec [ \"y1^1\" ] 200.0 encode_fragments () -> NDArray [ np . float32 ] Encodes the fragment ions as a numpy array The order of the ions will be defined in the config file. Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> spec . encode_fragments () array([200., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], dtype=float32) decode_fragments ( peptide : Peptide , fragment_vector : NDArray [ np . float32 ]) staticmethod Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> pep = spec . precursor_peptide >>> frags = spec . encode_fragments () >>> AnnotatedPeptideSpectrum . decode_fragments ( pep , frags ) AnnotatedPeptideSpectrum(mz=array([...]), intensity=array([...], dtype=float32), ms_level=2, precursor_mz=397.724526907315, precursor_charge=2, instrument=None, analyzer=None, collision_energy=nan, activation=None, extras={}, retention_time=RetentionTime(rt=nan, units='seconds', run=None), precursor_peptide=Peptide([...], {...}), precursor_isotope=0) to_sus () Return a spectrum object as a spectrum_utils.spectrum.Spectrum object Functions","title":"Spectrum objects"},{"location":"ms2ml%20API/spectra/#spectrum-objects","text":"","title":"Spectrum objects"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum","text":"Implements classes to represent spectra. This module implements classes to represent spectra and their annotations (when they have any). There are broadly two types of spectra: 1. General Spectra 2. Annotated Spectra","title":"spectrum"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum-classes","text":"","title":"Classes"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum","text":"Class to store the spectrum information. Examples: >>> spectrum = Spectrum ( ... mz = np . array ([ 1000.0 , 1500.0 , 2000.0 ]), ... intensity = np . array ([ 1.0 , 2.0 , 3.0 ]), ... precursor_mz = 1000.0 , ... precursor_charge = 2 , ... ms_level = 2 , ... extras = { \"EXTRAS\" : [ \"extra1\" , \"extra2\" ]}, ... ) >>> spectrum Spectrum(mz=array([1000., 1500., 2000.]), ...)","title":"Spectrum"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.mz","text":"","title":"mz"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.intensity","text":"","title":"intensity"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.ms_level","text":"","title":"ms_level"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.precursor_mz","text":"","title":"precursor_mz"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.precursor_charge","text":"","title":"precursor_charge"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.instrument","text":"","title":"instrument"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.analyzer","text":"","title":"analyzer"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.collision_energy","text":"","title":"collision_energy"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.activation","text":"","title":"activation"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.extras","text":"","title":"extras"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.retention_time","text":"","title":"retention_time"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.config","text":"","title":"config"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.__post_init__","text":"","title":"__post_init__()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.replace","text":"Replaces the attributes of the spectrum with the given values. Arguments are passed to the class Spectrum constructor. RETURNS DESCRIPTION Spectrum Spectrum, A new Spectrum object with the replaced attributes.","title":"replace()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.filter_top","text":"Filters the spectrum to the top n peaks. PARAMETER DESCRIPTION n The number of peaks to keep. TYPE: int RETURNS DESCRIPTION Spectrum The spectrum with the filtered top n peaks. Examples: >>> spectrum = Spectrum . _sample () >>> spectrum . intensity array([ 50., 200., 1., 2., 3.]) >>> spectrum . filter_top ( 2 ) . intensity array([ 50., 200.]) >>> Spectrum . _sample () . filter_top ( 3 ) . intensity array([ 3., 50., 200.])","title":"filter_top()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.filter_mz_range","text":"Filters the spectrum to a given m/z range. RETURNS DESCRIPTION Spectrum The spectrum with the filtered m/z range. Examples: >>> spectrum = Spectrum . _sample () >>> spectrum . mz array([ 50. , 147.11333, 1000. , 1500. , 2000. ]) >>> spectrum . tic 256.0 >>> spectrum = spectrum . filter_mz_range ( 124 , 1600 ) >>> spectrum . mz array([ 147.11333, 1000. , 1500. ]) >>> spectrum . filter_mz_range ( 124 , 1600 ) . tic 203.0","title":"filter_mz_range()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.remove_precursor","text":"Removes the precursor peak from the spectrum RETURNS DESCRIPTION Spectrum Spectrum, A new Spectrum object with the precursor peak removed.","title":"remove_precursor()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.intensity_cutoff","text":"Filters the spectrum to a given intensity cutoff. PARAMETER DESCRIPTION cutoff The intensity cutoff. All peaks with less than that intensity will be deleted. TYPE: float RETURNS DESCRIPTION Spectrum A new Spectrum object with the filtered intensity cutoff. Examples: >>> spectrum = Spectrum . _sample () >>> spectrum . intensity array([ 50., 200., 1., 2., 3.]) >>> spectrum . intensity_cutoff ( 2.1 ) . intensity array([ 50.0, 200., 3.]) >>> spectrum . intensity array([ 50., 200., 1., 2., 3.])","title":"intensity_cutoff()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.normalize_intensity","text":"Normalizes the spectrum intensities. PARAMETER DESCRIPTION method The method to use for normalization. Can be one of \"max\", \"sum\", \"rank\", \"log\". TYPE: str DEFAULT: 'max' RETURNS DESCRIPTION Spectrum The normalized spectrum. Examples: >>> spectrum = Spectrum . _sample () >>> spectrum . intensity array([ 50., 200., 1., 2., 3.]) >>> Spectrum . _sample () . normalize_intensity ( \"max\" ) . intensity array([0.25 , 1. , 0.005, 0.01 , 0.015]) >>> Spectrum . _sample () . normalize_intensity ( \"sum\" ) . intensity array([0.1953125 , 0.78125 , 0.00390625, 0.0078125 , 0.01171875]) >>> Spectrum . _sample () . normalize_intensity ( \"log\" ) . intensity array([3.91202301, 5.29831737, 0. , 0.69314718, 1.09861229]) >>> Spectrum . _sample () . normalize_intensity ( \"sqrt\" ) . intensity array([ 7.07106781, 14.14213562, 1. , 1.41421356, 1.73205081])","title":"normalize_intensity()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.encode_spec_bins","text":"Encodes the spectrum into bins. For a version of this function that takes arguments indead of reading the options from the config, see Spectrum.bin_spectrum . Uses the following options from the config Config.encoding_spec_bin_start, Config.encoding_spec_bin_end, Config.encoding_spec_bin_n_bins, Config.encoding_spec_bin_binsize, Config.encoding_spec_bin_relative, Config.encoding_spec_bin_offset, RETURNS DESCRIPTION NDArray [ np . float32 ] The encoded spectrum. Examples: >>> Spectrum . _sample () . encode_spec_bins () . shape (19999,)","title":"encode_spec_bins()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.bin_spectrum","text":"Bins the spectrum. PARAMETER DESCRIPTION start The start of the binning range. If missing will use the lowest mz value. TYPE: float end The end of the binning range. If missing will use the highest mz value. TYPE: float binsize The size of the bins. Cannot be used in conjunction with n_bins. TYPE: float | None DEFAULT: None n_bins The number of bins. Cannot be used in conjunction with binsize. TYPE: int | None DEFAULT: None relative Whether to use binning relative to the precursor mass. TYPE: bool DEFAULT: False offset The offset to use for relative binning. TYPE: float DEFAULT: 0 RETURNS DESCRIPTION NDArray [ np . float32 ] | tuple [ NDArray [ np . float32 ], NDArray [ np . float64 ]] An array of binned intensities.","title":"bin_spectrum()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.base_peak","text":"","title":"base_peak()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.tic","text":"","title":"tic()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.sic","text":"Returns the selected ion current for a given set of m/z values. PARAMETER DESCRIPTION mzs The m/z values to calculate the SIC for. TYPE: NDArray [ np . float32 ] resolution The function used to resolve ambiguities when multiple peaks match. possible options are sum and max . TYPE: Callable DEFAULT: sum RETURNS DESCRIPTION NDArray [ np . float32 ] An array of SIC values. This array will have the same length as the NDArray [ np . float32 ] input mzs array. Examples: >>> spectrum = Spectrum . _sample () >>> spectrum . mz array([ 50. , 147.11333, 1000. , 1500. , 2000. ]) >>> spectrum . intensity array([ 50., 200., 1., 2., 3.]) >>> spectrum . sic ( ... np . array ([ 1000.0 , 1000.00001 , 1500.0 , 2000.0 , 20_000.0 ]), ... resolution = sum , ... ) array([1., 1., 2., 3., 0.])","title":"sic()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.annotate","text":"Annotates the spectrum with the given peptide. PARAMETER DESCRIPTION peptide The peptide to annotate the spectrum with. TYPE: str | Peptide RETURNS DESCRIPTION AnnotatedPeptideSpectrum An AnnotatedPeptideSpectrum object. Examples: >>> spectrum = Spectrum . _sample () >>> peptide = Peptide . from_sequence ( \"PEPPINK/2\" , spectrum . config ) >>> annotated_spectrum = spectrum . annotate ( peptide ) >>> annotated_spectrum AnnotatedPeptideSpectrum(mz=array([ 50. ... precursor_isotope=0)","title":"annotate()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.to_sus","text":"","title":"to_sus()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.plot","text":"","title":"plot()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.Spectrum.stack","text":"Stacks multiple spectra into a single spectrum. PARAMETER DESCRIPTION spectra An iterable of spectra to stack. TYPE: Iterable [ Spectrum ] RETURNS DESCRIPTION Spectrum A stacked spectrum. Examples: >>> np . random . seed ( 0 ) >>> spectrum1 = Spectrum . _sample () >>> spectrum2 = Spectrum . _sample ( random = True ) >>> spectrum3 = Spectrum . _sample ( random = True ) >>> spectrum4 = Spectrum . _sample ( random = False ) >>> spectrum4 . mz = spectrum1 . mz + 1e-4 >>> mzs , ints = Spectrum . stack ([ spectrum1 , spectrum2 , spectrum3 , spectrum4 ]) >>> mzs array([ 50. , 147.11333 , 423.65479934, 437.58721126, 544.883183 , 592.84461823, 645.89411307, 1000. , 1500. , 2000. ]) >>> ints array([[ 50. , 0. , 0. , 50. ], [200. , 0. , 0. , 200. ], [ 0. , 0. , 963.6627605 , 0. ], [ 0. , 0. , 791.72503808, 0. ], [ 0. , 0. , 891.77300078, 0. ], [ 0. , 844.26574858, 0. , 0. ], [ 0. , 0. , 383.44151883, 0. ], [ 1. , 0. , 0. , 1. ], [ 2. , 0. , 0. , 2. ], [ 3. , 0. , 0. , 3. ]]) >>> ints . shape (10, 4)","title":"stack()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum","text":"Bases: Spectrum Class to store the spectrum information. In combination with the peptide information, it can be used to annotate the spectrum. Examples: >>> config = Config () >>> peptide = Peptide . from_sequence ( \"PEPPINK/2\" , config ) >>> spectrum = AnnotatedPeptideSpectrum ( ... mz = np . array ([ 50.0 , 147.11333 , 1000.0 , 1500.0 , 2000.0 ]), ... intensity = np . array ([ 50.0 , 200.0 , 1.0 , 2.0 , 3.0 ]), ... ms_level = 2 , ... extras = { \"EXTRAS\" : [ \"extra1\" , \"extra2\" ]}, ... precursor_peptide = peptide , ... precursor_mz = 147.11333 , ... ) >>> spectrum AnnotatedPeptideSpectrum(mz=array([ 50. ... precursor_isotope=0) >>> spectrum . fragment_intensities {'y1^1': 200.0} >>> spectrum [ \"y1^1\" ] 200.0 >>> spectrum . fragments {'y1^1': AnnotatedIon(mass=147.11334, charge=1, position=1, ion_series='y', intensity=200.0, neutral_loss=None)}","title":"AnnotatedPeptideSpectrum"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum-attributes","text":"","title":"Attributes"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.precursor_peptide","text":"","title":"precursor_peptide"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.precursor_isotope","text":"","title":"precursor_isotope"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.precursor_charge","text":"","title":"precursor_charge"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.charge","text":"","title":"charge"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.mass_error","text":"","title":"mass_error"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.fragment_labels","text":"Encodes the fragment ions as a numpy array The order of the ions will be defined in the config file. Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> spec . fragment_labels ['y1^1', ...]","title":"fragment_labels"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum-functions","text":"","title":"Functions"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.__post_init__","text":"","title":"__post_init__()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.fragment_intensities","text":"Returs a dictionary with the fragment ion names as keys and the corresponding intensities as values. Note The current implementation only keeps the last peak that matches the theoretical mass. future implementations should either keep all peaks or only the highest peak, or add the peaks. Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> spec . fragment_intensities {'y1^1': 200.0}","title":"fragment_intensities()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.fragments","text":"Returs a dictionary with the fragment ion names as keys and the corresponding AnnotatedIon objects as values. Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> spec . fragments {'y1^1': AnnotatedIon(mass=147.11334, charge=1, position=1, ion_series='y', intensity=200.0, neutral_loss=None)}","title":"fragments()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.__getitem__","text":"Returns the intensity of the fragment ion with the given name. Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> spec [ \"y1^1\" ] 200.0","title":"__getitem__()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.encode_fragments","text":"Encodes the fragment ions as a numpy array The order of the ions will be defined in the config file. Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> spec . encode_fragments () array([200., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], dtype=float32)","title":"encode_fragments()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.decode_fragments","text":"Examples: >>> spec = AnnotatedPeptideSpectrum . _sample () >>> pep = spec . precursor_peptide >>> frags = spec . encode_fragments () >>> AnnotatedPeptideSpectrum . decode_fragments ( pep , frags ) AnnotatedPeptideSpectrum(mz=array([...]), intensity=array([...], dtype=float32), ms_level=2, precursor_mz=397.724526907315, precursor_charge=2, instrument=None, analyzer=None, collision_energy=nan, activation=None, extras={}, retention_time=RetentionTime(rt=nan, units='seconds', run=None), precursor_peptide=Peptide([...], {...}), precursor_isotope=0)","title":"decode_fragments()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum.AnnotatedPeptideSpectrum.to_sus","text":"Return a spectrum object as a spectrum_utils.spectrum.Spectrum object","title":"to_sus()"},{"location":"ms2ml%20API/spectra/#ms2ml.spectrum-functions","text":"","title":"Functions"}]}